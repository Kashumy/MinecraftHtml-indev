

<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<html lang="en" onclick="openFullscreen()">

<div id="game-menu" class="none" style="position:fixed ;z-index:3; top:0;left:0;height:50vh;width:50vw;background : #CACACA6B ;color:white  ;font-size:24px; top:50vh; left :50vw; transform:translate(-50%,-50%);">

  <pre style="white-space :pre-wrap ">
 Workbench Classic Minecraft
 by: kashumyGithub
 orginal: mojang Minecraft 
</pre>
  <script>
    var isloading = 1
    var cloudsis = 1
var experiments={
  "test1":1,
}
    function openFullscreen() {
      var elem = document.documentElement;

      if (elem.requestFullscreen) {
        elem.requestFullscreen().then(rotateScreen);
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen().then(rotateScreen);
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen().then(rotateScreen);
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen().then(rotateScreen);
      }
      rotateScreen()
    }

    function rotateScreen() {
      if (screen.orientation) {

        screen.orientation.lock("landscape");
      }
    }
  </script>

</div>
<style>
  .alert2 {
    position: fixed;
    right: 20px;
    top: 20px;
    z-index: 2;
    width: 200px;
    height: 50px;
    background: #4C4C4C61;
    color: #FFFFFF;
  }
</style>
<script>
  function warn2(message) {
    var alertDiv = document.createElement("div");
    alertDiv.className = "alert2";
    alertDiv.innerHTML = message;

    document.body.appendChild(alertDiv);
    alertDiv.classList.add("show");

    setTimeout(function() {
      alertDiv.classList.remove("show");
      setTimeout(function() {
        alertDiv.remove();
      }, 300);
    }, 2000);
  }

  function menu_game() {
    document.getElementById('game-menu').classList.toggle('none')
  }
</script>

<style>
  .none {
    display: none;
  }
</style>

<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Menu</title>
  <style>
    dvt {
      position: fixed;
      background-image: url('./pobrane (7).png');
      background-size: 32px;
      background-repeat: repeat;
      filter: brightness(20%);
      width: 100%;
      height: 100vh;
      image-rendering: pixelated;
    }

    @font-face {
      font-family: 'mc';
      src: url('./Minecraft.ttf');
    }

    body {
      position: fixed;
      width: 100%;
      height: 100vh;
      background: #000000;
      margin: 0;
      padding: 0;

      font-family: "mc";
    }

    @media screen and (max-width: 769px) {
      dvt {}
    }

    .menu-container {
      text-align: center;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #42445A00;
      padding: 20px;
      border-radius: 10px;
    }

    .menu-button {
      display: block;
      background: url('./button.png');
      background-size: 100%;
      font-family: 'mc';

      background-repeat: no-repeat;
      width: 350px;
      padding: 10px;
      margin: 10px auto;

      color: white;
      text-decoration: none;

      font-size: 18px;
    }

    * {
      font-family: 'mc';
    }

    .menu-button:hover {}

    #logo {
      width: 260px;
      height: 100px;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      left: 50%;
      
image-rendering: pixelated;
zoom:0.9
    }

    .opct {
      opacity: 0;
      animation: opct 2s linear;
    }

    @keyframes opct {
      0% {
        opacity: 1;
      }

      100% {
        opacity: 0;
      }
    }
  </style>
</head>
<style>
  #splash {
    animation: buc 2s infinite;
    rotate: -10deg
  }

  @keyframes buc {
    0% {}

    50% {
      scale: 1.2
    }

    100% {
      scale: 1.0
    }
  }
</style>
<script>
  setTimeout(function() {
    var splashContainer = document.getElementById('splash');

    var splashes = [
"[ Object object ]",
"INDEV 0.5.2_pre 3",
" shiny GlowStone Gives light",
" You get Items in chest's ",
" warning Night is dangerous ",
" Build House In NIGHT !",
" Pro Tip: if you craft USE planks instead of sticks",
" Pro Tip: if you craft USE planks instead of sticks",
" Pro Tip: if you craft USE planks instead of sticks",
" Pro Tip: if you craft USE planks instead of sticks",
" Pro Tip: There is no Weapon in this game ONLY pickaxes" ,
" Pro Tip: craft wooden pickaxe to make stone pickaxe",
" craft the Pickaxe ",
" Creeper waiting in night",
" Do something "
  ];

    for (var i = 0; i < 20; i++) {
      var randomIndex = Math.floor(Math.random() * splashes.length);
      var splashText = splashes[randomIndex];

      var splashDiv = document.createElement('div');
      splashDiv.className = 'splash';
      splashDiv.textContent = splashText;

      splashContainer.innerHTML = splashDiv.innerText;
    }
  }, 3000);
</script>

<body>
  <dvt></dvt>

  <div id="ss" style="position:fixed ;z-index:3; top:0;left:0;height:100vh;width:100vw;background :white ;color:black ;font-size:4px; ">

    <img src="./logo.png" id="logo">
  </div>

  <div class="menu-container">
    <div style="position: absolute; top:0; left:0;"> indev 0.5.2.1 pre 2.4 </div>
    <img src="./Workbench.png" style="width :390px" alt="">
 <div id="splash" style="color :yellow; margin-top :-30px; margin-left :250px">
      Now on mobile
    </div>
    <a class="menu-button" onclick="play()">Play</a>
    <a class="menu-button" href="#">Options</a>
    <a class="menu-button" href="#">Exit Game</a>

  </div>
  <div style="position :fixed ; bottom :0px ; left :0px; color :white ;">
    Consout Copyright © You can distribute
  </div>
</body>

</html>
<script>
  if (isloading == 1) {
    setTimeout(function() {
      document.getElementById('ss').classList.add('opct')
      setTimeout(function() {
        document.getElementById('ss').style.display = "none"
      }, 2000)
    }, 6000)
  } else {
    setTimeout(function() {
      document.getElementById('ss').classList.add('opct')
      setTimeout(function() {
        document.getElementById('ss').style.display = "none"
        Start()
      }, 2000)

    }, 100)
  }
  var lbar = document.getElementById('lbar')
  var progress = 0

  function playworld(data) {

    lbar = document.getElementById('lbar')
    document.querySelector('.menu').style.display = "none"
    document.getElementById('lading').style.display = "block"
    var max = 100;

    for (var i = 0; i <= max; i++) {
      (function(i) {
        setTimeout(function() {
          progress += 1
          lbar.style.width = progress + "%"
        }, i * 100);
      })(i);
    }

    if (isloading == 1) {
      Start()
      setTimeout(function() {
        if (data == "world1") {
          document.getElementById('game-container').style.display = "block"

        }
      }, 13000)
    } else {
      if (data == "world1") {
        document.getElementById('game-container').style.display = "block"
        Start()
      }
    }

  }
  if (isloading == 1) {
    setTimeout(function() {
      document.getElementById('game-container').style.display = "none"
    }, 4000)
  }

  function play() {
    document.querySelector('.mmenu').style.display = "block"
  }

  function canel() {
    document.querySelector('.mmenu').style.display = "none"
  }
</script>
<div class="mmenu">

  <div id="lading" style="width :100%;height :100vh; display :none; position :absolute ">

    <pre style="color :white ; text-align :center ;position :absolute; transform:translate(-50%,-50%); top:calc(50vh - 60px); left :50vw;">Building terrain</pre>
    <div id="" style="width :200px;height :10px; position :absolute; transform:translate(-50%,-50%); top:50vh; left :50vw; background-color :gray ">

      <div id="lbar" style="width :0%; background :lime ; height :100%; filter :brightness(1.0)">

      </div>
    </div>

  </div>
  <div class="menu">

    <div onclick="playworld('world1')">world1</div>
    <div class="bt" id="bt" style="width :200px" onclick="canel()">canel</div>


  </div>
</div>

<style>
  #game-container {}

  .dead {
    animation: 0.15s dmg steps(1), 0.3s rtt;

  }

  @keyframes dmg {
    0% {
      filter: hue-rotate(-100deg);
      scale: 2.6
    }
  }

  @keyframes rtt {
    0% {
      scale: 2.0
    }

    50% {
      rotate: -5deg
    }

    100% {
      rotate: 5deg scale:1.5
    }
  }

  .menu {
    position: fixed;
    overflow: hidden;
    overflow: scroll;
    top: 50vh;
    left: 50vw;
    background: #0F0F0F80;
    transform: translate(-50%, -50%);
    width: 80%;
    padding: 10px;
    height: calc(50vh + 100px);
  }

  .menu div {
    width: calc(100% - 10px);
    background: url('./button.png');
    background-size: 100%;
    background-repeat: no-repeat;
    padding: 5px;
    margin-bottom: 5px;
    color: white;
    font-weight: bold;
    text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
    font-family: 'mc';
    height: 30px;

  }

  #bt {
    position: fixed;
    left: 20px;
    bottom: 0px
  }

  .bt {
    width: 40px;
    background: #747474;
    padding: 10px;
    background-size: 100%;
    background-repeat: no-repeat;
    padding: 5px;
    margin-bottom: 5px;
    color: #FFFFFF;
    font-weight: bold;
    text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
    font-family: 'mc';
    font-size: 13px;
    background-repeat: no-repeat;

  }

  .mmenu {
    position: fixed;
    display: none;
    width: 100%;
    height: 100%;
    background: url('./pobrane (8).png');
    background-size: 40px;
    image-rendering: pixelated;
    filter: brightness(0.5);
  }
</style>

<style>
  html {
    position: fixed;
    width: 100%;
    height: 100vh;
    user-select: none;
    user-zoom: none;
    min-zoom: 1;
    max-zoom: 1;
    margin: 0;
    padding: 0;
  }

  .item-slot {
    width: 50px;
    height: 50px;
    background: url('./itemslot.png');
    float: left;
    background-size: 100%;
    image-rendering: pixelated;
    margin-left: 3px;
    transition: background-color 0.3s ease;
  }

  .item-slot:hover {
    background: #f0f0f0;
  }

  #items {
    width: 370px;
    height: 100px;
    position: absolute;
    bottom: -10px;
    overflow: hidden;
    overflow: scroll;
    left: 55vw;
    background: #1E1E1E2E;
    transform: translate(-50%, 0%);
    z-index: 1;
  }

  body {}

  #game {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: #87CEEB;
    filter: saturate(96%) brightness(90%) contrast(90%) sepia(10%) grayscale(10%) invert(5%) hue-rotate(0deg);

  }

  #controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 2;
    width: 200px;
    overflow: hidden;
    zoom: 0.8
  }

  .null {
    user-select: none;
    width: 50px;
    margin: 5px;
    height: 50px;
    background: #42445A00;
    color: #FFFFFF;
    float: left;
  }

  button {
    margin: 5px;
  }

  .btn {
    border: 0px solid #626262;
    user-select: none;
    width: 50px;
    background: url('./btn.png');
    float: left;
    height: 50px;

    color: #FFFFFF;
  }

  #debug {
    width: 90px;
    height: 5px;
    padding: 10px;
    background: #FCFCFC6E;
    position: fixed;
    z-index: 9;
    bottom: 0;
    left: 0;
  }
</style>
</head>
<div id="debug">
  x:<t id="xpos"></t>y:<t id="ypos"></t>z:<t id="zpos"></t>
</div>
<div id="game-container">

  <div id="fps-counter" style="position: fixed ; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.5); color: white; padding: 5px; z-index :999"></div>
  <div id="items">
    <div id="hearts">
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>

    </div>
    <style>
      #hearts {
        width: 100%;
        height: 20px;

      }

      .heart {
        background-image: url('./heart.png');
        width: 20px;
        margin-left: -5px;
        height: 20px;
        float: left;
        image-rendering: pixelated;
        background-size: 100%;
      }

      .night {
        background-color: #000000;
        animation: nights 35s forwards steps(30);
      }

      .day {
        background-color: #53D8F0;
        animation: days 35s forwards steps(30);
      }

      @keyframes nights {
        0.1% {
          background: #87CEEB;
        }

        30% {
          background: linear-gradient(#3988A2, #EBAF1A);
        }

        50% {
          background: #0E4E69;
        }

        80% {
          background: #07244F;
        }

        100% {
          background: #000000;
        }
      }

      @keyframes days {
        0.1% {
          background: #000000;
        }

        20% {
          background: #07244F;
        }

        50% {
          background: #0E4E69;
        }

        70% {
          background: #3983A2;
        }

        99.9% {
          background: #87CEEB;
        }

        100% {
          background: #000000;
        }
      }
    </style>
  <!--  <div class="item-slot" onclick="switchi('pickaxe')"><img style="width:60%;height :60%;margin :20%" src="./pickaxe.png" alt=""></div>-->
    

    <style>
        /* Dodaj odpowiednie style dla crafting table */
        #crafting-table {
            display: none;
            width: 200px;
            height: 200px;
            border: 1px solid black;
            z-index: 99;
            position: fixed;
            background: #52525278;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crafting-table2 {
          display: none;
          width: 100px;
          height: 100px;
          border: 1px solid black;
          z-index: 99;
          position: fixed;
          background: #52525278;
          top: 40%;
          left: 50%;
          transform: translate(-50%, -50%);
        }
        .crafting-slot {
            width: 66.6px;
            height: 66.6px;
            float: left;
            border: 1px solid gray;
            box-sizing: border-box;
            text-align: center;
            line-height: 100px;
        }
                .crafting-slot2 {
                  width:50px;
                  height:50px;
                  float: left;
                  border: 1px solid gray;
                  box-sizing: border-box;
                  text-align: center;
                  line-height: 100px;
                }
    </style>

    <!-- Dodaj nowy slot Inventory, który będzie toggle'ować crafting table -->
    <div class="item-slot" onclick="toggleCraftingTable2()">
        <img style="width: 60%; height: 60%; margin: 20%" src="./btn.png" alt="">
    </div>
<div class="item-slot"  onclick=" craftItem2();craftItem()">
    <img style="width: 60%; height: 60%; margin: 20%" src="./btn.png" alt="">
</div>


    <script>
        
    </script>



  </div>

    <div id="crafting-table">
        <!-- Dodaj 9 slotów do crafting table -->
        <div class="crafting-slot" onclick="placeItemInCraftingTable(1)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(2)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(3)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(4)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(5)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(6)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(7)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(8)"></div>
        <div class="crafting-slot" onclick="placeItemInCraftingTable(9)"></div>
    </div>

    <div id="crafting-table2">
        <!-- Dodaj 9 slotów do crafting table -->
        <div class="crafting-slot2" onclick="placeitemincraftingtable2(1)"></div>
        <div class="crafting-slot2" onclick="placeitemincraftingtable2(2)"></div>
        <div class="crafting-slot2" onclick="placeitemincraftingtable2(3)"></div>
        <div class="crafting-slot2" onclick="placeitemincraftingtable2(4)"></div>

    </div>

    <script type="module">

      import * as THREE from "./three.module.js"; 
      import { GLTFLoader } from "./GLTFLoader(1).js"; 
window.THREE = THREE;
window.GLTFLoader = GLTFLoader;
</script>


    <script>
var currentitem=0
setTimeout(function(){

        // Tworzenie obiektu slidera
        function Slider(config) {
          this.name = config.name;
            this.min = config.min;
            this.max = config.max;
            this.addby = config.addby;
            this.variable = config.variable;
        }

        // Funkcja do dodawania slidera do elementu na stronie
        function appendslider(slider, elementId) {
            var element = document.querySelector(elementId);
var sliderName = document.createElement("div");
sliderName.innerText=slider.name

            // Utwórz element suwaka
            var sliderElement = document.createElement("input");
            sliderElement.type = "range";
            sliderElement.min = slider.min;
            sliderElement.max = slider.max;
            sliderElement.step = slider.addby;

            // Dodaj obsługę zdarzenia zmiany wartości suwaka
            sliderElement.addEventListener("input", function() {
                // Ustaw wartość zmiennej na wartość slidera
                warn2(sliderElement.value)
                window[slider.variable]  = parseFloat(sliderElement.value);
                
                console.log("Nowa wartość zmiennej:", window[slider.variable]  );
                defrdist=rdist
            });

            // Dodaj suwak do elementu na stronie
            
            element.appendChild(sliderName);
            element.appendChild(sliderElement);
        }

        
var Slider1 = new Slider({'name':"chunk size" ,'min': 10, 'max': 30, 'addby': 2, 'variable': 'rdistD'});
appendslider(Slider1, ".menu");

var Slider2a = new Slider({ 'name': "number of terrain's ", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numberterains1D' });
appendslider(Slider2a, ".menu");

var Slider3a = new Slider({ 'name': "Heigh Terrain", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numofcirclesD' });
appendslider(Slider3a, ".menu");

var Slider4a = new Slider({ 'name': "Number of Trees", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numberOfTreesD' });
appendslider(Slider4a, ".menu");

},Infinity);

    var cantbuildthisblockGeometry = 0;
    var items = {
      "1": ["stone", 0, "./pobrane (14).png"],
      "2": ["grass", 0, "./pobrane (9).png"],
      "3": ["wood", 0, "./pobrane (10).png"],
      "4": ["water", 0, "./water.png", "water2"],
      "5": ["leaves", 0, "./pobrane (19).png"],
      "6": ["brick", 0, "./pobrane (12).png"],
      "7": ["glass", 0, "./glass.png"],
      "8": ["glowstone", 0, "./glowstone.png"],
      "9": ["polishedstone", 0, "./pobrane (11).png"],
      "10":["wooden_pickaxe", 0 ,"./wood_pickaxe.png",1],
      "11":["stone_pickaxe", 0 ,"./stone_pickaxe.png",1],
      "12":["iron_ore", 0 ,"./iron_ore.png"],
 "13":["coal_ore", 0 ,"./coal_ore.png"],
"14":["iron_pickaxe", 0,"./pickaxe.png",1],
      "15":["iron", 0 ,"./iron.png",1],
            "16":["crafting", 0 ,"./crafting_table_front.png"],
 "17":["diamond_ore", 0 ,"./diamond_ore.png"],
  "18":["diamond_pickaxe", 0 ,"./diamond_pickaxe.png"],
    };
    var nocollisions = ["water"]


function findItemIndex(itemName) {
    for (const index in items) {
        if (items[index][0] === itemName) {
            return index;
        }
    }
    return null; // Zwróć null, jeśli przedmiot nie zostanie znaleziony
}

    function createItemSlots() {
      const itemSlotsContainer = document.getElementById('items');

      const maxSlots = Math.min(20, Object.keys(items).length);

      for (let i = 1; i <= maxSlots; i++) {
        const itemInfo = items[i.toString()];
        const [itemName, itemCount, itemImage] = itemInfo;

        const itemSlot = document.createElement('div');
        itemSlot.className = 'item-slot';
        itemSlot.style.position = 'relative';
        itemSlot.id = `itemslot${i}`

        itemSlot.innerHTML = `
           <img style="width:60%;height:60%;margin:20%" src="${itemImage}"  alt="">
           <p id="items-slot-${i}" style="position:absolute;top:0%;z-index:99;left:0%;color:white">x${itemCount}</p>
         `;
        itemSlot.addEventListener('click', function() {
          switchi(itemName);
          currentitem = findItemIndex(itemName);
        });

        itemSlotsContainer.appendChild(itemSlot);
      }
    }

    window.addEventListener('load', createItemSlots);

    function checkItemSlotsForItems() {
      const itemSlotsContainer = document.getElementById('items');

      setInterval(() => {
        for (let i = 1; i <= Object.keys(items).length; i++) {
          const itemInfo = items[i.toString()];
          const [itemName, itemCount] = itemInfo;
          const itemSlot = document.getElementById(`itemslot${i}`);

          if (itemCount < 1) {

            itemSlot.style.display = 'none';
          } else {

            itemSlot.style.display = 'block';

          }
        }
      }, 1000);
    }

    window.addEventListener('load', checkItemSlotsForItems);

    var currentitemslot = '';

    function updateInventory() {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          var item = items[key];
          var itemName = item[0];
          var itemCount = item[1];
          var slotId = "items-slot-" + key;
          var slotElement = document.getElementById(slotId);
          if (slotElement) {
            slotElement.textContent = "x" + itemCount;
          }

        }
      }
      checkItm(currentitemslot)
    }

    function addblock(typ3) {
      var searchedItem = typ3;
      var index = -1;

      for (var key in items) {
        if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
          index = key;
          break;
        }
      }
      items[index][1] += 1
      updateInventory()
    }
function subblock(typ3) {
  var searchedItem = typ3;
  var index = -1;

  for (var key in items) {
    if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
      index = key;
      break;
    }
  }
  items[index][1] -= 1
  updateInventory()
}
    function useblock(typ3) {

      items[typ3][1] -= 1

      updateInventory()

    }

    function checkItm(typ3) {
      var searchedItem = currentitemslot;
      var index = -1;

      for (var key in items) {
        if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
          index = key;
          if (items[index][1] < 1) {
            cantbuildthisblockGeometry = 1
          } else {
            cantbuildthisblockGeometry = 0
          }
          break;
        }
      }

    }
    updateInventory()
  </script>

  <img src="./croschair.png" style="position :fixed ; transform:translate(-50%,-50%); top:50vh ;left :50vw; z-index :1">

  <div id="game2" style="position:absolute;background: black; width:100%; height:100vh;">
  </div>
  <canvas id="game"></canvas>
  <div id="controls">
    <div class="null"></div>
    <button id="moveForward" class="btn"></button>
    <div class="null"></div>
    <button id="moveLeft" class="btn"></button>
    <div class="null"></div>

    <button id="moveRight" class="btn"></button>
    <div class="null"></div>
    <button id="moveBackward" class="btn"></button>

  </div>
  <button id="jump" style="position :fixed ; z-index: 2; right :50px; bottom: 20px" class="btn"></button>
  <button id="empty"  onclick="menu_game()" style="position :fixed ; right :0px; top: 50px ; font-weight :bold " class="btn">|&nbsp;&nbsp;|</button>

</div>






<script>

var numberOfTreesD = 3;
var numofcirclesD = 1
var numberterains1D = 2
var rdistD = 13
var defrdistD = 10


var switchi;

 function Start() {

setTimeout( function() {
  
var steponstone = 0
  var fpsCounter = document.getElementById('fps-counter');

  var frameCount = 0;
  var lastTime;
  var fps;

  function updateFPS() {
    var currentTime = performance.now();
    frameCount++;

    if (!lastTime) {
      lastTime = currentTime;
      return;
    }

    var elapsedMilliseconds = currentTime - lastTime;

    if (elapsedMilliseconds >= 1000) {
      fps = Math.round((frameCount * 1000) / elapsedMilliseconds);
      fpsCounter.innerHTML = 'FPS: ' + fps;
      frameCount = 0;
      lastTime = currentTime;
    }
  }

  let defaultFps = 30
  let targetFPS = 25;
  let frameTime = 1000 / targetFPS;

  const scene = new THREE.Scene();
  
  var canv = document.getElementById("game");
  var width = canv.clientWidth;
  var height = canv.clientHeight;

  const camera = new THREE.PerspectiveCamera(
    90,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  var renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("game"), alpha: true, antialias: true });
  
//renderer.setPixelRatio(window.devicePixelRatio);
//renderer.toneMapping = THREE.ReinhardToneMapping;
//renderer.gammaFactor = 0.2;  // Eksperymentuj z różnymi wartościami
//renderer.outputEncoding = THREE.sRGBEncoding;

//renderer.toneMappingExposure = 0.3;
//renderer.outputEncoding = THREE.sRGBEncoding;
//renderer.physicallyCorrectLights = true;
//renderer.precision = 'mediump'; // Dostosuj precision, może pomóc w komunikatach o highp

  var lod = new THREE.LOD();

  renderer.setSize(window.innerWidth, window.innerHeight);

 
var ambientLight=new THREE.AmbientLight(0x505050)
  scene.add(ambientLight);
  
  var light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(0, 3, 0);
  light.target = scene;
//  light.castShadow = true;
//  light.receiveShadow = true;
  light.shadowDarkness = 0.5;
  light.shadowCameraNear = 0.1;
  scene.add(light);

 // THREE.ColorManagement.enabled = false;

  scene.fog = new THREE.FogExp2(0xffffff, 0.009);

  renderer.shadowMapEnabled = true;
renderer.shadowMapSoft = true;

  const playerGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
  const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00000000, transparent: true, opacity: 0.0 });
  const player = new THREE.Mesh(playerGeometry, playerMaterial);
  scene.add(player);

  var textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load('./pobrane (12).png');

  const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

  var textureTop = new THREE.TextureLoader().load('./grass.png');
textureTop.magFilter = THREE.NearestFilter;
textureTop.minFilter = THREE.NearestFilter;


  var textureBottom = new THREE.TextureLoader().load('./pobrane (8).png');
  textureBottom.magFilter = THREE.NearestFilter;
  textureBottom.minFilter = THREE.NearestFilter;
  var textureSides = new THREE.TextureLoader().load('./front2.png');
  textureSides.magFilter = THREE.NearestFilter;
  textureSides.minFilter = THREE.NearestFilter;
  var water = new THREE.TextureLoader().load('./water.png');

  var textureSides2 = new THREE.TextureLoader().load('./pobrane (13).png');
  textureSides2.magFilter = THREE.NearestFilter;
  textureSides2.minFilter = THREE.NearestFilter;
  var wood = new THREE.TextureLoader().load('./cobble.png');
  wood.castShadow = true
  wood.receiveShadow = true
  var stone1 = new THREE.TextureLoader().load('./pobrane (7).png');
  var stone3 = new THREE.TextureLoader().load('./pobrane (10).png');
  var wood1 = new THREE.TextureLoader().load('./pobrane (16).png');
  var leaves = new THREE.TextureLoader().load('./pobrane (19).png');
  leaves.magFilter = THREE.NearestFilter;
  leaves.minFilter = THREE.NearestFilter;
leaves.castShadow = true
  leaves.receiveShadow = true
  
  wood1.magFilter = THREE.NearestFilter;
  wood1.minFilter = THREE.NearestFilter;
  stone1.magFilter = THREE.NearestFilter;
  stone1.minFilter = THREE.NearestFilter;
  
  stone1.castShadow = true
  stone1.receiveShadow = true
  stone3.magFilter = THREE.NearestFilter;
  stone3.minFilter = THREE.NearestFilter;
  stone3.castShadow = true
  stone3.receiveShadow = true
  var chet1 = new THREE.TextureLoader().load('./chest_front.png');
  chet1.magFilter = THREE.NearestFilter;
  chet1.minFilter = THREE.NearestFilter;
  var chest = new THREE.MeshLambertMaterial({ map: chet1, });

  var water2 = new THREE.MeshLambertMaterial({ map: water,  transparent: true, opacity: 0.9 });
  var stone = new THREE.MeshLambertMaterial({ map: stone1
  });
stone.castShadow = true
stone.receiveShadow = true
  var wooden = new THREE.MeshLambertMaterial({ map: wood, });
  wooden.castShadow = true
  wooden.receiveShadow = true
  var stonen = new THREE.MeshLambertMaterial({ map: stone3,  });
  stonen.castShadow = true
  stonen.receiveShadow = true
  var material2 = new THREE.MeshLambertMaterial({ map: textureSides2,  });
  var materialTop = new THREE.MeshLambertMaterial({ map: textureTop, transparent: true, opacity: 1 });
  var materialBottom = new THREE.MeshLambertMaterial({ map: textureBottom,  });
  var materialSides = new THREE.MeshLambertMaterial({ map: textureSides,/* shading: THREE.FlatShading */});

  const blockMaterial = new THREE.MeshLambertMaterial({ map: texture,  });

  var materials = [
  materialSides,
  materialSides,
  materialTop,
  materialBottom,
  materialSides,
  materialSides,

];
materials.castShadow=true

materials.receiveShadow=true
  var blocks = [];
  var renderingdist = 7

  var chunks = [];
  var rdist = rdistD

  function checkAndRemoveDuplicateBlocks(currentChunkX, currentChunkZ) {
    const radius = rdist;

    const blocksToRemove = [];

    for (let i = 0; i < blocks.length; i++) {
      const blockA = blocks[i];

      const distance = camera.position.distanceTo(blockA.position);

      if (distance <= radius) {
        const blockChunkX = Math.floor(blockA.position.x / rdist);
        const blockChunkZ = Math.floor(blockA.position.z / rdist);

        if (blockChunkX === currentChunkX && blockChunkZ === currentChunkZ) {
          for (let j = i + 1; j < blocks.length; j++) {
            const blockB = blocks[j];

            if (
              blockA.position.x === blockB.position.x &&
              blockA.position.y === blockB.position.y &&
              blockA.position.z === blockB.position.z
            ) {
              blocksToRemove.push(blockB);
            }
          }
        }
      }
    }

    blocksToRemove.forEach((block) => {
      scene.remove(block);
      const index = blocks.indexOf(block);
      if (index !== -1) {
        blocks.splice(index, 1);
      }
    });

    targetFPS = defaultFps;
    frameTime = 1000 / targetFPS;
  }

  function removeBlocksNearCamera() {
    const radius = 200;

    const blocksToRemove = blocks.filter((block) => {
      const distance = camera.position.distanceTo(block.position);
      return distance <= radius;
    });

    blocksToRemove.forEach((block) => {
      scene.remove(block);
      const index = blocks.indexOf(block);
      if (index !== -1) {

      }
    });
  }
  var worldFlat = 0
  var chunkX = 0
  var chunkZ = 0

  function generateChunk(x, z) {
    chunkX = x
    chunkZ = z

    targetFPS = 10;
    frameTime = 1000 / targetFPS;
    removeBlocksNearCamera()

//    renderingdist = 0
    const chunk = new THREE.Group();

    const layerHeight = -3;
    const voxelSize = 1;
    const gridSize = 20;
    var numCircles = numofcirclesD;
    const fillRadius = 0;

    const voxelsize2 = 1;
    const gridsize2 = 20;
    const fillRadius2 = 0;

    const voxelCoordinates = [
            [0, 0, 0],
            [1, 0, 0],

            [2, 0, 1],
            [2, 0, 2],
            [1, 0, 2],
            [0, 0, 2],
            [2, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [1, 1, 0],

            [2, 1, 1],
            [2, 1, 2],
            [1, 1, 2],
            [0, 1, 2],
            [2, 1, 0],
            [0, 1, 1],
            [1, 2, 0],
            [1, 2, 1],
            [2, 2, 1],
            [1, 2, 2],
            [0, 2, 1],
[1, 1, 1, 1],
[1, 0, 1, 1],
[1, -1, 1, 1],
[1, -2, 1, 1]

        ];

    let randomz = Math.floor(Math.random() * 20) 
    let randomx = Math.floor(Math.random() * 20) 
    var trees = 0;
    const numberOfTrees = numberOfTreesD;
    if (worldFlat == 0) {
      for (let i = 0; i < numberOfTrees; i++) {
        const randomx = Math.floor(Math.random() * rdist);
        const randomz = Math.floor(Math.random() * rdist) ;

        voxelCoordinates.forEach(coords => {
          const [x2, y2, z2, type] = coords;
          let material = new THREE.MeshLambertMaterial({ map: leaves});
          if (type === 1) {
            material = new THREE.MeshLambertMaterial({ map: wood1});
          }

          const block = new THREE.Mesh(new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize), material);
          block.position.set(x2 + randomx + x * rdist, y2, z2 + randomz + z * rdist);
          block.name = 'leaves'
          if (type == 1) {
            block.name = 'woodblock'
          }
block.castShadow = true;
block.receiveShadow = true;

          blocks.push(block);

        });
      }
    }
    let numOfterains1 = Math.floor(Math.random() * numberterains1D)
    if (worldFlat == 0) {
      for (let j2 = 0; j2 < numOfterains1; j2++) {
        let randomXZ = Math.floor(Math.random() * rdist)
        let randomZX = Math.floor(Math.random() * rdist)
        numCircles = Math.floor(Math.random() * 3) + 4
        for (var m = -2; m < Math.floor(2); m++) {
          numCircles -= 1
          const dwn = m
          for (let i = 0; i < numCircles; i++) {
            const radius = (Math.random() * 0.5) + i;
            const segments = 64;

            for (let j = 0; j < segments; j++) {
              const angle = (j / segments) * Math.PI * 2;
              const xv = (Math.cos(angle) * radius) + (x * rdist);
              const zv = (Math.sin(angle) * radius) + (z * rdist);
              const yv = -2;

              const distanceToCenter = Math.sqrt(xv * xv + zv * zv);

              if (distanceToCenter > fillRadius) {
                const block = new THREE.Mesh(blockGeometry, materials);
                block.position.set(Math.floor(xv) + randomXZ, dwn, Math.floor(zv) + randomZX);

                block.name = 'grass'
                blocks.push(block)
block.receiveShadow = true;
block.castShadow = true;
              }
            }
          }
        }
      }
    }
    for (let x2 = 0; x2 < rdist; x2++) {
      for (let z2 = 0; z2 < rdist; z2++) {

        if (Math.floor(Math.random() * 30) == 1) {
          let block = new THREE.Mesh(blockGeometry, materials);
          block.name = 'grass'
          block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);
//scene.add(block)
          blocks.push(block);
block.castShadow = true;
block.receiveShadow = true;

        } else {
          if (Math.floor(Math.random() * 20) == 3) {
            let block = new THREE.Mesh(blockGeometry, water2);

            block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);

            block.name = 'water'

            blocks.push(block);

          } else {
            let block = new THREE.Mesh(blockGeometry, materials);

            block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);

            block.name = 'grass'
            blocks.push(block);
block.castShadow = true;
block.receiveShadow = true;

          }
          if (Math.floor(Math.random() * 155) == 5) {
            block = new THREE.Mesh(blockGeometry, chest);
            block.name = 'chest'
            block.position.set(x2 + x * rdist, layerHeight + 1, z2 + z * rdist);

            blocks.push(block);
          }
        }

      }

    }

    for (let x2 = 0; x2 < rdist; x2++) {
      for (let y2 = 0; y2 < 2; y2++)
        for (let z2 = 0; z2 < rdist; z2++) {

          if (Math.floor(Math.random() * 15) == 3) {
            var block = new THREE.Mesh(blockGeometry, materials);
            var itemTexture = new THREE.TextureLoader().load('./pobrane (12).png');
            itemTexture.magFilter = THREE.NearestFilter;
            itemTexture.minFilter = THREE.NearestFilter;
            var itemMaterial = new THREE.MeshLambertMaterial({ map: itemTexture });
            block.material = itemMaterial;
            block.name = "brick"

          } else {
            var block = new THREE.Mesh(blockGeometry, stone);
            block.name = 'stone'
            block.castShadow = true;
block.receiveShadow = true;

          }

          block.position.set(x2 + x * rdist, -4 -
            y2, z2 + z * rdist);

          blocks.push(block);

        }
    }

    chunks.push({ x, z, chunk });
    generateChunkinprocess_Cave(x, z)

    setTimeout(function() {
      checkAndRemoveDuplicateBlocks(x, z)
      //renderingdist = 6
    }, 4000)
  }

  const frustum = new THREE.Frustum();

  function updateFrustum() {
    camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
  }

  function isObjectVisible(object) {
    return frustum.intersectsObject(object);
  }
  let renderDistance = 3

  function isBlockVisible(block) {
    const distance = camera.position.distanceTo(block.position);
    return distance < renderDistance;
  }
  const blocksInCave = [];

  var gins = 0

  function generateChunkinprocess_Cave(x, z) {

    const chunk = new THREE.Group();

    const startHeight = -6;

    const endHeight = -31;

    let layerHeight = startHeight;
    let x2 = 0;
    let z2 = 0;
    

    function generateLayer() {

      for (let y = 0; y < 2; y++) {
        for (let i = 0; i < rdist; i++) {

          if (layerHeight > endHeight) {

            const block = new THREE.Mesh(blockGeometry, stone);
            block.position.set(x2 + x * rdist, layerHeight , z2 + z * rdist);

            block.name = "stone"
            if (Math.floor(Math.random() * 200) == 5) {
              var itemTexture = new THREE.TextureLoader().load("./coal_ore.png");
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var coal_ore = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
              block.material = coal_ore;
              block.name = "coal_ore"
            }else if (Math.floor(Math.random() * 80) == 5) {
              var itemTexture = new THREE.TextureLoader().load("./iron_ore.png");
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var iron_ore = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
              block.material = iron_ore;
              block.name = "iron_ore"
            }else if (Math.floor(Math.random() * 100) == 5) {
              var itemTexture = new THREE.TextureLoader().load("./coal_ore.png");
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
              block.material = itemMaterial;
              block.name = "coal_ore"
            }
if(layerHeight < -28){
  var itemTexture = new THREE.TextureLoader().load("./bedrock.png");
  itemTexture.magFilter = THREE.NearestFilter;
  itemTexture.minFilter = THREE.NearestFilter;
  var itemMaterial = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
  block.material = itemMaterial;
  block.name = "bedrock"
}

if (layerHeight < -25) {
  if (Math.floor(Math.random() * 100) == 5) {
  var itemTexture = new THREE.TextureLoader().load("./diamond_ore.png");
  itemTexture.magFilter = THREE.NearestFilter;
  itemTexture.minFilter = THREE.NearestFilter;
  var itemMaterial = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
  block.material = itemMaterial;
  block.name = "diamond_ore"
  }
}
            blocks.push(block);
          //  blocksInCave.push(block);

            x2++;
            if (x2 >= rdist) {
              x2 = 0;
              z2++;
              if (z2 >= rdist) {
                z2 = 0;
                layerHeight--;
              }
            }
          }
        }

      }

      if (layerHeight > -30) {
        requestAnimationFrame(generateLayer);

      }
      

      

      }

    

    generateLayer();

    chunks.push({ x, z, chunk });
  }

  function updateOcclusionCulling() {

  }

  function updateBlockfaceCulling() {

  }

  var visibleblocks = []

  function scheduleRandomExecution() {
    const minInterval = 5000;
    const maxInterval = 60000;

    const randomInterval = Math.random() * (maxInterval - minInterval) + minInterval;

  }

  scheduleRandomExecution();

  const occlusionRadius = 2;
/*  const cameraFrustum = new THREE.Frustum();
  const cameraViewProjectionMatrix = new THREE.Matrix4();

  camera.updateMatrixWorld();
  const matrixInv = new THREE.Matrix4().copy(camera.matrixWorld).invert();
  cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, matrixInv);

  cameraFrustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
*/
var darkercave=-5
var defaultlight=0.7

function GRAPHICS(){

  const gameElement = document.getElementById('game')
  if (player.position.y < darkercave) {
    gameElement.style.background = "#000"
    light.intensity = 0.02;
    scene.remove(ambientLight)
    ambientLight = new THREE.AmbientLight(0x242424)
    scene.add(ambientLight)
    scene.fog = new THREE.FogExp2(0x000000, 0.09);
  } else if (Time == "day") {
    light.intensity = defaultlight;
    gameElement.style.background = "#87CEEB"
    scene.remove(ambientLight)
    ambientLight = new THREE.AmbientLight(0x515151)
    scene.add(ambientLight)
    scene.fog = new THREE.FogExp2(0xffffff, 0.060);
  } else if (Time == "night") {
    light.intensity = 0.02;
    gameElement.style.background = "#000"
    scene.remove(ambientLight)
    ambientLight = new THREE.AmbientLight(0x111111)
    scene.add(ambientLight)
    scene.fog = new THREE.FogExp2(0x000000, 0.10);
  }
}
window.setInterval(GRAPHICS,5000)

var GNUN=0
  function updaterenderdistance(playerChunkX, playerChunkZ, playerChunkY) {
    
  const occlusionRadius = renderingdist;
  const additionalDistance = 3;

  const blocksInCurrentChunk = blocks.filter(block => {
    const blockChunkX = Math.floor(block.position.x / rdist);
    const blockChunkZ = Math.floor(block.position.z / rdist);
   // const blockChunkY = Math.floor(block.position.y / rdist/2);
    return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ //&& blockChunkY === playerChunkY;
  });
  
 /* if (playerChunkY !== GNUN) {
    GNUN = playerChunkY
const blocksInCurrentChunk2 = blocks.filter(block => {
  const blockChunkX = Math.floor(block.position.x / rdist);
  const blockChunkZ = Math.floor(block.position.z / rdist);
  const blockChunkY = Math.floor(block.position.y / rdist/2);
  return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ //&& blockChunkY === playerChunkY;
});

}*/

  blocksInCurrentChunk.forEach(block => {
    const distance = camera.position.distanceTo(block.position);

    // Zmniejsz occlusionRadius tylko w osi Y o 2 bloki
    const occlusionRadiusY = occlusionRadius - 2;

    if (distance <= occlusionRadiusY + additionalDistance) {
      if (distance <= occlusionRadiusY) {
        if (!scene.children.includes(block)) {
          scene.add(block);
        }
      } else {
        if (scene.children.includes(block)) {
          scene.remove(block);
        }
      }
    } 
  });
}


  let one = 0

  function updatePlayerChunk() {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);


    if (!chunks.some(chunk => chunk.x === playerChunkX && chunk.z === playerChunkZ)) {

      for (let i = chunks.length - 1; i >= 0; i--) {
      /*  const chunk = chunks[i];
        if (Math.abs(chunk.x - playerChunkX) > 1 || Math.abs(chunk.z - playerChunkZ) > 1) {


        }*/
      }

      generateChunk(playerChunkX, playerChunkZ);
      player.position.y = 4
      
    }
  }

  const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
  const skyMaterial = new THREE.MeshLambertMaterial({ color: 0x87EEEB, side: THREE.BackSide });
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);

//scene.add(sky)
  const clouds = [];
  if (cloudsis == 1) {
    for (let i = 0; i < 200; i++) {
      const cloudGeometry = new THREE.BoxGeometry(Math.random() * 10 + 15, 0, Math.random() * 10 + 10);
      const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud.position.set(Math.random() * 400 - 150, 15, Math.random() * 500 - 150);
      clouds.push(cloud);
      scene.add(cloud);
    }
  }

  camera.position.z = -15;
  camera.position.y = 1;
  camera.rotation.order = 'YXZ';

  const gravity = new THREE.Vector3(0, -0.045, 0);
  const playerVelocity = new THREE.Vector3();
  setTimeout(function() {

    player.position.y = 10
    player.position.x = 5
  player.position.z = 5
    playerVelocity.set(0, 0, 0);
    setTimeout(function() {

      player.position.y = 10
      player.position.x = 5
      player.position.z = 5
      playerVelocity.set(0, 0, 0);

    }, 1000)
  }, 2100)

  const playerSpeed = 0.3;

  const moveForwardButton = document.getElementById('moveForward');
  const moveBackwardButton = document.getElementById('moveBackward');
  const moveLeftButton = document.getElementById('moveLeft');
  const moveRightButton = document.getElementById('moveRight');
  const jumpButton = document.getElementById('jump');

  let forwardPressed = false;
  let backwardPressed = false;
  let leftPressed = false;
  let rightPressed = false;
  let jumpPressed = false;

  moveForwardButton.addEventListener('touchstart', () => {
    forwardPressed = true;
  });
  moveForwardButton.addEventListener('touchend', () => {
    forwardPressed = false;
  });

  moveBackwardButton.addEventListener('touchstart', () => {
    backwardPressed = true;
  });
  moveBackwardButton.addEventListener('touchend', () => {
    backwardPressed = false;
  });

  moveLeftButton.addEventListener('touchstart', () => {
    leftPressed = true;
  });
  moveLeftButton.addEventListener('touchend', () => {
    leftPressed = false;
  });

  moveRightButton.addEventListener('touchstart', () => {
    rightPressed = true;
  });
  moveRightButton.addEventListener('touchend', () => {
    rightPressed = false;
  });
  var cantjump = 0
  var jumping = 1
  jumpButton.addEventListener('touchstart', (event) => {
    event.preventDefault()
    if (cantjump == 0) {
      jumpposition = player.position.y
      jumpPressed = true;
    } else if (jumping > 0) {
      jumpposition = player.position.y
      jumpPressed = true;
      jumping = -1
    }
  });
  jumpButton.addEventListener('click', (event) => {
    event.preventDefault()
    if (cantjump == 0) {
      jumpposition = player.position.y
      jumpPressed = true;
    } else if (jumping > 0) {
      jumpposition = player.position.y
      jumpPressed = true;
      jumping = -1
    }

  });

  const stopMovement = () => {
    playerVelocity.set(0, 0, 0);

  };
  var Movementspeed = 0.24;

  var jumpposition = 0
  var fallingdmgisactive = 0;
  setTimeout(function() {
    fallingdmgisactive = 1
  }, 6000)
  let forwalking = 0
  let D20times = 0
  let D5times

  const creepers = [];


  


  const handleCollisions = (object, blocks) => {
    const objectBox = new THREE.Box3().setFromObject(object);

    for (const block of blocks) {
      const blockBox = new THREE.Box3().setFromObject(block);

      if (!nocollisions.includes(block.name)) {
        const halfWallHeight = block.geometry.parameters.height / 2.0;
        const halfWallDepth = block.geometry.parameters.depth / 2.8;
        const halfWallWidth = block.geometry.parameters.width / 2.8;

        if (
          object.position.x - 0.5 < block.position.x + halfWallWidth &&
          object.position.x > block.position.x &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          object.position.x += 0.3;
        }

        if (
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x < block.position.x &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          object.position.x -= 0.3;
        }

        if (
          object.position.z - 0.5 < block.position.z + halfWallDepth &&
          object.position.z > block.position.z &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          object.position.z += 0.3;
        }

        if (
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z < block.position.z &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          object.position.z -= 0.3;
        }

        if (
          object.position.y - 0.5 < block.position.y + halfWallHeight &&
          object.position.y > block.position.y  &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {

          object.position.y += 0.2;
const distanceToPlayer = object.position.distanceTo(player.position);

if (distanceToPlayer <= 5) {
  
  const playerDirection = new THREE.Vector3().copy(player.position).sub(object.position);
  playerDirection.y = object.position.y;
  playerDirection.normalize();

  const speed = 0.10;
  object.position.add(playerDirection.multiplyScalar(speed));
}
        } else if (!(object.position.y - 0.8 < block.position.y + halfWallHeight &&
            object.position.y > block.position.y &&
            object.position.x + 0.5 > block.position.x - halfWallWidth &&
            object.position.x - 0.5 < block.position.x + halfWallWidth &&
            object.position.z + 0.5 > block.position.z - halfWallDepth &&
            object.position.z - 0.5 < block.position.z + halfWallDepth)) {

        }






      }
    }
  };
  let ghs = 0

  function OneHurt() {
    if (ghs == 0) {
      ghs = 1
      hurt()
      hurt()
      setTimeout(hurt,500)
      setTimeout(function() {
        hurt()
        ghs = 0
      }, 1000)
    }
  }

  let LplayerChunkX = Math.floor(player.position.x / rdist);
 // let LplayerChunkY = Math.floor(player.position.x / rdist/2);
  let LplayerChunkZ = Math.floor(player.position.z / rdist);

  let creeperVelocity = 0.05

  const animate = () => {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);
const playerChunkY = Math.floor((player.position.y) / rdist/4);
    LplayerChunkX = Math.floor(player.position.x / rdist);
    LplayerChunkZ = Math.floor(player.position.z / rdist);

    if (D5times < 1) {
      D5times++
    } else {

      updaterenderdistance(playerChunkX, playerChunkZ, playerChunkY)
      D5times=0
    }
    if (D20times < 10) {

      D20times++
    } else {
      D20times = 0
      updatePlayerChunk()
    }

    if (player.position.y < -100) {
      player.position.y = 20
    }
    document.getElementById("xpos").innerHTML = Math.floor(camera.position.x)
    document.getElementById("ypos").innerHTML = Math.floor(camera.position.y)
    document.getElementById("zpos").innerHTML = Math.floor(camera.position.z)
    updateFPS();
    setTimeout(() => {
     requestAnimationFrame(animate);
    }, frameTime);

    camera.position.set(player.position.x, player.position.y + 1.3, player.position.z);
    camera.rotation.order = 'YXZ';

    playerVelocity.add(gravity);

    const playerVelocity2 = new THREE.Vector3(0, 0, 0);

    if (forwardPressed) {

      const speed = Movementspeed;
      if (forwalking < 5) {
        forwalking++
      } else {
        var audio = new Audio('./grass1.ogg');
        forwalking = 0

        audio.play();
      }

      const direction = new THREE.Vector3(0, 0, -1.5);
      direction.applyQuaternion(camera.quaternion).normalize();

      const playerVelocity2 = new THREE.Vector3(direction.x * speed, 0, direction.z * speed);

      player.position.add(playerVelocity2);

    }

    else if (backwardPressed) {
      camera.translateZ(Movementspeed);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else {
      playerVelocity.z = 0;
    }

    if (leftPressed) {
      camera.translateX(Movementspeed * -1);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else if (rightPressed) {
      camera.translateX(Movementspeed);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else {
      playerVelocity.x = 0;
    }

    if (jumpPressed) {
      playerVelocity.y = 0.30;
      jumpPressed = false;
    }

    player.position.add(playerVelocity);

    const halfPlayerWidth = 0.5;
    const halfPlayerHeight = 0.4;
    const halfPlayerDepth = 0.5;

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
     // const blockChunkY = Math.floor(block.position.y / rdist/4);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ// && blockChunkY === playerChunkY ;
    });

    creepers.forEach(creeper => {

      if (!creeper.wanderTimer) {
        creeper.wanderTimer = 0;
        creeper.wanderDuration = 4;
        creeper.inAttackRange = false;
      }

      const distanceToPlayer = creeper.position.distanceTo(player.position);
      if (creeper.position.y <= -30) {
        scene.remove(creeper);

        const index = creepers.indexOf(creeper);
        if (index !== -1) {
          creepers.splice(index, 1);
        }
        return 0;
      } else
      if (distanceToPlayer <= 1) {
        scene.remove(creeper);

        const index = creepers.indexOf(creeper);
        if (index !== -1) {
          creepers.splice(index, 1);
        }

        OneHurt()
        return 0;
      } else {
        if (distanceToPlayer <= 5) {
          

          
          creeper.inAttackRange = true;
        } else {

        }
        if (!(distanceToPlayer <= 1)) {
          creeper.position.y -= 0.2;
          handleCollisions(creeper, blocksInCurrentChunk);
        }

      }
      if (distanceToPlayer < 7) {
        creeper.lookAt(player.position.x * -1, creeper.position.y, player.position.z * -1)
      
      
      }
    });

// Funkcja sprawdzająca czy blok jest w zasięgu gracza
function isBlockInRadius(block, playerPosition, radius) {
    const distanceSquared = block.position.distanceToSquared(playerPosition);
    return distanceSquared <= radius * radius;
}

// Funkcja zwracająca bloki w zasięgu gracza
function getBlocksInRadius(blocks, playerPosition, radius) {
    return blocksInCurrentChunk.filter(block => isBlockInRadius(block, playerPosition, radius));
}

// Użycie funkcji do znalezienia bloków w zasięgu gracza
const blocksNearPlayer = getBlocksInRadius(blocks, player.position, 3);



    for (const block of blocksNearPlayer) {
      const box1 = new THREE.Box3().setFromObject(player);
      const box2 = new THREE.Box3().setFromObject(block);

      if (box1.intersectsBox(box2)) {

      }
      if (!nocollisions.includes(block.name)) {

        const halfWallHeight = block.geometry.parameters.height / 2.0;
        const halfWallDepth = block.geometry.parameters.depth / 2.8;
        const halfWallWidth = block.geometry.parameters.width / 2.8;

        if (
          player.position.x - 0.5 < block.position.x + halfWallWidth &&
          player.position.x > block.position.x &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          player.position.x += 0.3;
        }

        if (
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x < block.position.x &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          player.position.x -= 0.3;
        }

        if (
          player.position.z - 0.5 < block.position.z + halfWallDepth &&
          player.position.z > block.position.z &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          player.position.z += 0.3;
        }

        if (
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z < block.position.z &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          player.position.z -= 0.3;
        }

        if (
          player.position.y - 0.4 < block.position.y + halfWallHeight &&
          player.position.y > block.position.y &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {

          playerVelocity.set(0, 0, 0);
          player.position.y += (block.position.y - player.position.y) + 0.8;
          cantjump = 0;
          if (block.name === "stone") {
            steponstone = 1;
          }
          jumping = 1;
          if (player.position.y < jumpposition - 1.5) {
            hurt();
          }
        } else {
          cantjump = 1;
          if (block.name !== "stone") {
            steponstone = 0;
          }
          if (fallingdmgisactive == 1) {
            if (playerVelocity.y < 0) {

            }
          }
        }
      }
    }

    for (const cloud of clouds) {
      cloud.position.x -= 0.1;
      if (cloud.position.x < -150) {
        cloud.position.x = 300;
      }
    }
if (experiments.test1 == 0) {
  renderer.render(scene, camera);
}
  };

  animate();

  function fastrendering() {
    if(experiments.test1==1){
    renderer.render(scene, camera);
    
    requestAnimationFrame(fastrendering)
    }
  }
  fastrendering()

  lod.addLevel(scene, 1);

  let touchStartX = 0;
  let touchStartY = 0;

  function onTouchStart(event) {
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
  }
var Movingcamera=0
  function onTouchMove(event) {
    if(presstodel!==1){
    Movingcamera=1
    }
    const touchX = event.touches[0].clientX;
    const touchY = event.touches[0].clientY;

    const deltaX = (touchX - touchStartX) * 0.02;
    const deltaY = (touchY - touchStartY) * 0.02;

    camera.rotation.y -= deltaX;
    camera.rotation.x -= deltaY;

    touchStartX = touchX;
    touchStartY = touchY;
  }
function endedTouching(event){
  Movingcamera=0
}
  document.addEventListener('touchstart', onTouchStart);
  document.addEventListener('touchmove', onTouchMove);
document.addEventListener('touchend', endedTouching);
  const previewGeometry = new THREE.BoxGeometry(1, 1, 1);

  const blockMaterial2 = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });

  let previewBlock = new THREE.Mesh(previewGeometry, blockMaterial2);

  scene.add(previewBlock);

  function animateOpacity() {
    const opacityValue = previewBlock.material.opacity;
    showIndicationForWallsinOtherBlocks()

    const targetOpacity = opacityValue === 0.6 ? 0.2 : 0.6;

    const duration = 300;
    const startTime = Date.now();

    function updateOpacity() {
      const currentTime = Date.now() - startTime;
      const progress = Math.min(currentTime / duration, 1);
      const newOpacity = opacityValue + (targetOpacity - opacityValue) * progress;

      previewBlock.material.opacity = newOpacity;

      if (progress < 1) {
        requestAnimationFrame(updateOpacity);

      }
    }

    updateOpacity();
  }

  setInterval(animateOpacity, 400);

  let previewBlockAdded = false;

  function showIndicationForWallsinOtherBlocks(event) {
    updateInventory();
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);
const playerChunkY = Math.floor(player.position.y / rdist/4);
    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      const blockChunkY = Math.floor(block.position.y / rdist/4);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ && playerChunkY == blockChunkY;
    });

    const intersects = raycaster.intersectObjects(blocksInCurrentChunk);

    if (intersects.length > 0) {
      const clickedBlock = intersects[0].object;
      const blockPosition = new THREE.Vector3();
      clickedBlock.getWorldPosition(blockPosition);

      blockPosition.x = Math.floor(blockPosition.x);
      blockPosition.y = Math.floor(blockPosition.y);
      blockPosition.z = Math.floor(blockPosition.z);

      const intersectionPoint = intersects[0].point;
      const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

      let newPosition = blockPosition.clone();

      if (relativePosition.y > 0) {
        newPosition.y += 1;
      } else if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {

        newPosition.x += Math.sign(relativePosition.x);
      } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {

        newPosition.z += Math.sign(relativePosition.z);
      } else {

      }

      previewBlock.position.copy(newPosition);
      previewBlockAdded = true;

    } else {

      if (previewBlockAdded) {

        previewBlock.position.set(Infinity, Infinity, Infinity);
        previewBlockAdded = false;

      }
    }
  }

  function buildBlockOnClick(event) {
    updateInventory()
    

    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(blocks);

    if (intersects.length > 0) {

      const clickedBlock = intersects[0].object;
      const nameblock= clickedBlock.name
      const blockPosition = new THREE.Vector3();
      clickedBlock.getWorldPosition(blockPosition);

      blockPosition.x = Math.floor(blockPosition.x);
      blockPosition.y = Math.floor(blockPosition.y);
      blockPosition.z = Math.floor(blockPosition.z);

      const intersectionPoint = intersects[0].point;
      const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

if(nameblock!=='crafting'){
      if (currentblock == 'stone') {
        currentitemslot = 'stone';
        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, wooden);
          newBlock.name = "stone"
          var searchedItem = "stone";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      } else if (currentblock == 'wood') {
        currentitemslot = 'wood'

        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, stonen);
          newBlock.name = 'wood'
          var searchedItem = "wood";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      } else if (currentblock == 'grass') {
        currentblock = 'grass'
        currentitemslot = 'grass'
        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = 'grass'
          var searchedItem = "grass";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      }
      else if (currentblock == 'glowstone') {
        currentitemslot = currentblock;

        if (cantbuildthisblockGeometry === 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = currentitemslot;

          var searchedItem = currentitemslot;
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }

          if (index !== -1) {
            if (items[index][3] && window.hasOwnProperty(items[index][3])) {

              var customMaterial = window[items[index][3]];
              newBlock.material = customMaterial;
            } else {

              var itemTexture = new THREE.TextureLoader().load(items[index][2]);
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshBasicMaterial({ map: itemTexture, transparent: true, alpha: true });
              newBlock.material = itemMaterial;
            }
          }

          useblock(index);
        }
      }
      else {

        currentitemslot = currentblock;
//alert(currentitemslot)
var searchedItem = currentitemslot;
var index = -1;
for (var key in items) {
  if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
    index = key;
    break;
  }
}

if (index !== -1) {
  if (items[index][4]!==1) {
        if (cantbuildthisblockGeometry === 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = currentitemslot;

          var searchedItem = currentitemslot;
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }

          if (index !== -1) {
            if (items[index][3] && window.hasOwnProperty(items[index][3])) {

              var customMaterial = window[items[index][3]];
              newBlock.material = customMaterial;
            } else {

              var itemTexture = new THREE.TextureLoader().load(items[index][2]);
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshLambertMaterial({ map: itemTexture, transparent: true, alpha: true });
              newBlock.material = itemMaterial;
            }
          }

          useblock(index);
        }

      }
}}
      let newPosition = blockPosition.clone();

      if (relativePosition.y > 0) {
        newPosition.y += 1;
      }
      else
      if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {

        newPosition.x += Math.sign(relativePosition.x);
      } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {

        newPosition.z += Math.sign(relativePosition.z);
      } else {

        newPosition.y += Math.sign(relativePosition.y);
      }

      var audio = new Audio('./stone4.ogg');

      audio.play();
      newBlock.position.copy(newPosition);

      scene.add(newBlock);
      blocks.push(newBlock);

      addPointLightsToGlowstones()
    }else{
      toggleCraftingTable()
    }
setTimeout(function (){
  Movingcamera=0
},600)
}
  }

  let glowstoneLightsMap = new Map();

  function addPointLightsToGlowstones() {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
    });


    glowstoneLightsMap.forEach((light, block) => {
      if (!blocksInCurrentChunk.includes(block) || !isGlowstonePresent(block.position)) {
        scene.remove(light);


        if (light) {
          if (light.material) light.material.dispose();
          if (light.geometry) light.geometry.dispose();
        }

        glowstoneLightsMap.delete(block);


        const torchIndex = torches.indexOf(block);
        if (torchIndex !== -1) {
          torches.splice(torchIndex, 1);
        }
      }
    });


    blocksInCurrentChunk.forEach(block => {
      if (block.name === 'glowstone' && isGlowstonePresent(block.position)) {
        const existingLight = glowstoneLightsMap.get(block);

        if (existingLight) {

          existingLight.position.copy(block.position);
        } else {

          const blockLight = new THREE.SpotLight(0xffffff, 5,6,3,0);
          blockLight.position.copy(block.position);
          scene.add(blockLight);

          torches.push(block);
          glowstoneLightsMap.set(block, blockLight);
        }
      }
    });
  }


  function isGlowstonePresent(position) {








    return blocks.some(glowstone => glowstone.position.equals(position) && glowstone.name === 'glowstone');
  }


  let torches = [];

  window.setInterval(addPointLightsToGlowstones, 9500);


  const blockDurability = {
  wood: 10,
  leaves:1,
  water:1,
  stone: 15,
  brick: 10,
  glass: 1,
  glowstone: 1,
  polishedstone: 20,
  grass: 3,
  woodblock: 10, // Adjust durability for woodblock
  chest: 1 ,
  iron_ore: 25,
  coal_ore: 15,
  diamond_ore: 15,
  crafting:20
};
let durability=0
function deleteBlockOnClick(event) {
  const mouse = new THREE.Vector2();
  mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
  mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObjects(blocks);

  if (intersects.length > 0) {
    const clickedBlock = intersects[0].object;
    const blockName = clickedBlock.name;

    if (blockDurability[blockName] !== undefined) {
      




      if (currentblock == 'wooden_pickaxe') {
          var searchedItem = "wooden_pickaxe";
          var index = -1;
          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          if(items[index][1]>-1){
durability+=1.5;
//alert(items[index][1])
}else{
  currentblock=''
  //currentitem=''
  warn2("Pickaxe braked")
}useblock(index)} else if (currentblock == 'stone_pickaxe') {
          var searchedItem = "stone_pickaxe";
          var index = -1;
          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          if(items[index][1]>-1){
durability++;durability++;durability+=1.5;
//alert(items[index][1])
}else{
  currentblock=''
  //currentitem=''
  warn2("Pickaxe braked")
}useblock(index)}
 if (currentblock == 'iron_pickaxe') {
          var searchedItem = "iron_pickaxe";
          var index = -1;
          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          if(items[index][1]>-1){
durability++;durability++;durability+=1.5;durability+=1.5;durability++;
//alert(items[index][1])
}else{
  currentblock=''
  //currentitem=''
  warn2("Pickaxe braked")
}useblock(index)}
if (currentblock == 'diamond_pickaxe') {
          var searchedItem = "diamond_pickaxe";
          var index = -1;
          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          if(items[index][1]>-1){
durability++;durability++;durability+=3;durability+=2;durability++;
//alert(items[index][1])
}else{
  currentblock=''
  //currentitem=''
  warn2("Pickaxe braked")
}useblock(index)}




      durability++;
var audio = new Audio('./stone4.ogg');
audio.play();
      if (blockDurability[blockName] <= durability) {
        durability=0
        if (blockName === "diamond_ore") {
          if ( currentblock == 'iron_pickaxe'|| currentblock == 'diamond_pickaxe') {
            addblock("diamond_ore");
            recipesadd("Diamonds !", "./diamond_ore.png");
          }
        }else
        if (blockName === "stone") {
          if (currentblock == 'wooden_pickaxe' || currentblock == 'stone_pickaxe' ||currentblock == 'iron_pickaxe'|| currentblock == 'diamond_pickaxe') {
          addblock("stone");
          recipesadd("Stone age!", "./cobble.png");
          }
        }else if (blockName === "iron_ore") {
          if (currentblock == 'stone_pickaxe' || currentblock == 'iron_pickaxe'|| currentblock == 'diamond_pickaxe') {
            addblock("iron");
            recipesadd("Iron !", "./iron_ore.png");
          }
        }else if (blockName === "chest") {
          if (Math.floor(Math.random() * 3) == 2) {
            for (var i = 0; i < 30; i++) {
              addblock("brick");
            }
          } else if (Math.floor(Math.random() * 2) == 1) {
            for (var i = 0; i < 30; i++) {
              addblock("glass");
            }
          } else if (Math.floor(Math.random() * 3) == 1) {
            for (var i = 0; i < 30; i++) {
              addblock("wood");
            }
          } else if (Math.floor(Math.random() * 3) == 1) {
            for (var i = 0; i < 15; i++) {
              addblock("polishedstone");
            }
          } else {
            for (var i = 0; i < 2; i++) {
              addblock("glowstone");
              recipesadd("Rare Loot!", "./chest_front.png");
            }
          }
        } else if (blockName === "woodblock") {
          // Adjust code for woodblock
          for (var i = 0; i < 4; i++) {
            addblock("wood");
          }
          recipesadd("Get Wood!", "./pobrane (16).png");
        } else if (blockName === "grass") {
          addblock("grass");
        } else {
          addblock(blockName);
        }

        var audio = new Audio('./stone1.ogg');
        audio.play();

        const index = blocks.indexOf(clickedBlock);
        if (index !== -1) {
          blocks.splice(index, 1);
          scene.remove(clickedBlock);
        }

        addPointLightsToGlowstones();
      }
    }
  }
}
var presstodel=0
var clicking=0
document.addEventListener("click", function (event){
  event.preventDefault()
clicking=1
}
)

var touchTimer;

document.querySelector('html').addEventListener("touchstart", function(event) {
  event.preventDefault()
    touchTimer = setTimeout(function() {
        // Your code to execute after holding for 1 second
        if (Movingcamera == 0) {
//warn2("Holding for 1 second");
            presstodel = 1;
        }
    }, 1000); // Set the timeout to 1000 milliseconds (1 second)
});

document.querySelector('html').addEventListener("touchend", function(event) {
    clearTimeout(touchTimer); // Clear the timer if touch is
    presstodel=0
    Movingcamera=0
})

function checkiy(){
  
   // warn2("ok")
  if(presstodel==1&&Movingcamera==0){ deleteBlockOnClick(event) ;}
    
  
  setTimeout(checkiy,200)
}
checkiy()
  let elapsedTime = 0;
  var Time="day"
const loader = new GLTFLoader();
  function changeBackgroundAndLight() {
Time="night"
    for (var i = 0; i < 2; i++) {
      
recipesadd("Night Time ", "./chest_front.png");
      scene.fog = new THREE.FogExp2(0x000000, 0.09);
// Remove the existing Mesh creation
// const creeper3 = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0x00dd00 }));

// Comment out the existing line adding creeper3 to creepers array
// creepers.push(creeper3);



loader.load(
  './model.gltf', // Update the path
  (gltf) => {
    let creeper3 = gltf.scene; // Use gltf.scene as the new creeper3

    creeper3.scale.set(0.05, 0.055, 0.05);
    creeper3.position.set(chunkX * rdist + Math.floor(Math.random() * rdist), 5, chunkZ * rdist + Math.floor(Math.random() * rdist));

    scene.add(creeper3);
    creepers.push(creeper3);
  }
);

    }

    const duration = 15000;
    const startTime = Date.now();
    const minLightIntensity = 0.02;

    const gameElement = document.getElementById('game');

    function update() {
      const currentTime = Date.now() - startTime;

      const progressLight = Math.min(currentTime / duration, 1);
      const newLightIntensity = Math.max(minLightIntensity, 0.9 - 0.2 * progressLight * 5);
      light.intensity = newLightIntensity;

      gameElement.classList.add('night')
      scene.remove(ambientLight)
      ambientLight = new THREE.AmbientLight(0x111111)
      scene.add(ambientLight)
      scene.fog = new THREE.FogExp2(0x000000, 0.3);

      if (currentTime < duration) {
        requestAnimationFrame(update);

      } else {
        setTimeout(changeBackgroundAndLight2, 200000);
      }
    }

    update();
  }

  setTimeout(changeBackgroundAndLight, 400000);

  function changeBackgroundAndLight2() {
    Time="day"
    const duration = 35000;
    const startTime = Date.now();
    const minLightIntensity = 0.02;

    const gameElement = document.getElementById('game');

    function update() {
      const currentTime = Date.now() - startTime;

      const progressLight = Math.min(currentTime / duration, 1);
      const newLightIntensity = Math.min(0.6, minLightIntensity + 0.2 * progressLight * 2);
      light.intensity = newLightIntensity;

      gameElement.classList.add('day');
recipesadd("Survive first Day", "./glowstone.png");
scene.fog = new THREE.FogExp2(0xffffff, 0.015);
     scene.remove(ambientLight)
     
      ambientLight = new THREE.AmbientLight(0x707070)
      scene.add(ambientLight)
      scene.fog = new THREE.FogExp2(0xffffff, 0.09);

      if (currentTime < duration) {

        requestAnimationFrame(update);
        gameElement.classList.remove('night');
      } else {
        gameElement.classList.remove('day');
        setTimeout(changeBackgroundAndLight, 300000);
      }
    }

    update();
  }

var  currentblock = ''
var  blockClickEnabled = false

 switchi =  function(data) {
   
    if (data == "stone") {

 //    canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'stone'
    } else if (data == "wood") {

     // canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'wood'
    } else if (data == "grass") {

    //  canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'grass'
    } else if (data == "pickaxe") {

      //canv.removeEventListener('click', buildBlockOnClick);
  //    canv.addEventListener('click', deleteBlockOnClick);
  
currentblock=''
    }else if (data == "wooden_pickaxe") {
    
     canv.removeEventListener('click', buildBlockOnClick);
   //   canv.addEventListener('click', deleteBlockOnClick);
   
   
   
    currentblock = 'wooden_pickaxe'
    }else if (data == "stone_pickaxe") {
    
        canv.removeEventListener('click', buildBlockOnClick);
      //   canv.addEventListener('click', deleteBlockOnClick);
    
    
    
      currentblock = 'stone_pickaxe'
    } else {

   //   canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = data
    }
  }

  window.addEventListener('resize', function() {
    var newScreenWidth = window.innerWidth;
    var newScreenHeight = window.innerHeight;

    renderer.setSize(newScreenWidth, newScreenHeight);

    camera.aspect = newScreenWidth / newScreenHeight;
    camera.updateProjectionMatrix();
  });

  function fori() {
    camera.getWorldPosition(cameraPosition);
    camera.getWorldDirection(cameraDirection);

    var blockPosition = block.getWorldPosition(new THREE.Vector3());

    var directionToBlock = blockPosition.sub(cameraPosition).normalize();

    var dotProduct = cameraDirection.dot(directionToBlock);
    if (dotProduct > 0.99) {

      block.material.color.set(0xffffff);
     // block.material.emissive.set(0xffffff);
    } else {

      block.material.color.set(0x00ff00);
      //block.material.emissive.set(0x000000);
    }
  }

  function test() {

  }
  window.setInterval(test, 10000)

  var hurtperseconds = 0

  let canHurt = true;
  let lastHurtTime = 0;

  function hurt() {
    jumpposition = player.position.y;
    const currentTime = Date.now();
    const timeSinceLastHurt = currentTime - lastHurtTime;
    document.getElementById('game').classList.add('dead');
    setTimeout(function() {
      document.getElementById('game').classList.remove('dead');
    }, 10000);

    
    if (timeSinceLastHurt >= 100) {

      const heartsContainer = document.getElementById("hearts");

    const lastHeart = heartsContainer.lastChild;
heartsContainer.removeChild(lastHeart);
      setTimeout(function() {
        if (heartsContainer.children.length > 0) {

          
          

          if (heartsContainer.children.length === 0) {

            warn2("You died");

            for (var i = 0; i < 11; i++) {
              heartsContainer.innerHTML += '<div class="heart"></div>';
            }
            player.position.y = 15;
            player.position.x = 15;
            player.position.z = 15;
            playerVelocity.set(0, 0, 0);

          }
        }
      }, 500);

      lastHurtTime = currentTime;
      var audio = new Audio('hurt.ogg');
      
      audio.play();
    }
  }

  function test2() {

  }
},1000);
}
</script>

<script>
  var audio2 = new Audio('./hal3.ogg');

  function playnaunce1() {
    let random = Math.floor(Math.random() * 2)

    if (audio2.paused) {
      audio2.src = './calm1.ogg';
      if (random == 0) {

        audio2.src = './hal3.ogg';
      }
      if (random == 1) {

        audio2.src = './nuance1.ogg';
        warn2(random)
      } 
      if (random > 1 && random < 3) {
        audio2.src = './calm3.ogg'
      } else
      if (random > 2 && random < 4) {
        audio2.src = './calm1.ogg'
      }
      audio2.play();
    }

  }
  window.setInterval(playnaunce1, 10000)
</script>

    <style>
        #recipeBar {
            position: fixed;
            white-space: pre-wrap;
            top: 10px;
            right: -400px;
            width: 200px;
            height: 30px;
            background-color: #787878;
            color: white;
            text-align: right;

            padding: 10px;
            transition: 2.5s;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #recipeBar img {
            position: absolute;
            left: 5px;
            top: 5px;
            width: 40px;
            height: 40px;
            margin-right: 10px;
            image-rendering:pixelated;
        }
    </style>
</head>
<body>

<pre id="recipeBar" ></pre>

<script>
    let unlockedRecipes = [];

    function isRecipeAdded(recipe) {
        return unlockedRecipes.includes(recipe);
    }

    function recipesadd(recipe, img) {
        
        if (isRecipeAdded(recipe)) {
            console.log("Receptura już dodana");
            return;
        }else{

        
        unlockedRecipes.push(recipe);

        
        const recipeBar = document.getElementById("recipeBar");
        recipeBar.innerHTML = `<img src="${img}" alt="${recipe}">${recipe}            `;

        
        setTimeout(() => {
            recipeBar.style.right = "-5px";
        }, 200);

        
        setTimeout(() => {
            recipeBar.style.right = "-400px";
        }, 5000);
        }
    }

</script>
    <script>
        let craftingTableVisible = false;
        let currentCraftingItem =  0

        function toggleCraftingTable() {
            const craftingTable = document.getElementById('crafting-table');
            craftingTableVisible = !craftingTableVisible;
            craftingTable.style.display = craftingTableVisible ? 'block' : 'none';
        }

        // Dodaj craftingRecipes
var craftingRecipes = {
    "wooden_pickaxe": [["wood", "wood", "wood",null, "wood", null, null, "wood", null]],
    "stone_pickaxe": [["stone", "stone", "stone",null, "wood", null, null, "wood", null]],
    "iron_pickaxe": [["iron", "iron", "iron",null, "wood", null, null, "wood", null]],
    "diamond_pickaxe": [["diamond_ore", "diamond_ore", "diamond_ore",null, "wood", null, null, "wood", null]],
};

function craftItem() {
    // Iterate through craftingRecipes
    for (const recipe in craftingRecipes) {
        if (JSON.stringify(itemsincrafting) === JSON.stringify(craftingRecipes[recipe][0])) {
          currentCraftingItem=recipe
            // Matched a recipe, create the item
            if (currentCraftingItem === "wooden_pickaxe" && recipe === "wooden_pickaxe") {
                for (var i = 0; i < 100; i++) {
                    addblock(currentCraftingItem);
                }
            }else if (currentCraftingItem === "stone_pickaxe" && recipe === "stone_pickaxe") {
              for (var i = 0; i < 250; i++) {
                addblock(currentCraftingItem);
              }
            }else if (currentCraftingItem === "iron_pickaxe" && recipe === "iron_pickaxe") {
              for (var i = 0; i < 450; i++) {
                addblock(currentCraftingItem);
              }
            }else if (currentCraftingItem === "diamond_pickaxe" && recipe === "diamond_pickaxe") {
              for (var i = 0; i < 700; i++) {
                addblock(currentCraftingItem);
              }
            }
            clearCraftingTable();
            break; // Stop checking once a match is found
        }
    }
}




function clearCraftingTable() {
    for (let i = 0; i < 9; i++) {
        const craftingSlot = document.getElementsByClassName('crafting-slot')[i];
        craftingSlot.innerHTML = '';
    }
/*
    // Usuń użyte przedmioty
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            const requiredItem = craftingRecipes[currentCraftingItem][i][j];
            const requiredIndex = findItemIndex(requiredItem);
            items[requiredIndex][1] -= 1;
        }
    }
*/updateCraftingItems();
    updateInventory();
}
var itemsincrafting=[null,null,null,null,null,null,null,null,null]
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
function placeItemInCraftingTable(slotNumber) {
    const craftingSlot = document.getElementsByClassName('crafting-slot')[slotNumber - 1];

    if (craftingSlot.innerHTML) {
      const itemName = items[currentitem][0];
        // Jeśli coś jest już umieszczone w crafting table, usuń to przy podwójnym kliknięciu
        addblock(craftingSlot.innerHTML.includes('alt') ? craftingSlot.querySelector('img').alt : null)
        craftingSlot.innerHTML = '';
      //  currentCraftingItem = null;
        updateCraftingItems();
        
    } else {

   //     currentCraftingItem = items[currentitem][0];
        const itemName = items[currentitem][0];
        if(items[currentitem][1]>0){
        craftingSlot.innerHTML = `<img style="width: 100%; height: 100%;" src="./${items[currentitem][2]}" alt="${itemName}">`;
        subblock(itemName)
        updateCraftingItems();
        }
    }
}

function updateCraftingItems() {
    for (let i = 0; i < 9; i++) {
        const craftingSlot = document.getElementsByClassName('crafting-slot')[i];
        itemsincrafting[i] = craftingSlot.innerHTML.includes('alt') ? craftingSlot.querySelector('img').alt : null;
    }
    
}

// Dodaj przycisk do kraftowania

    </script>




<!-- crafting 2-->

    <script>
let craftingTableVisible2 = false;
        let currentCraftingItem2 =  0

        function toggleCraftingTable2() {
            const craftingTable = document.getElementById('crafting-table2');
            craftingTableVisible2 = !craftingTableVisible2;
            craftingTable.style.display = craftingTableVisible2 ? 'block' : 'none';
        }

        // Dodaj craftingRecipes2
var craftingRecipes2 = {
        "crafting": [["wood", "wood", "wood", "wood"]],
        "glowstone": [["coal_ore", null,"wood",null]],
};

function craftItem2() {
    // Iterate through craftingRecipes2
    
    for (const recipe in craftingRecipes2) {
    //  alert(JSON.stringify(itemsincrafting2)+" 2: "+JSON.stringify(craftingRecipes2[recipe][0]))
      
        if (JSON.stringify(itemsincrafting2) === JSON.stringify(craftingRecipes2[recipe][0])) {
          currentCraftingItem2=recipe
addblock(currentCraftingItem2)
            clearCraftingTable2();
            break; // Stop checking once a match is found
        }
    }
}




function clearCraftingTable2() {
    for (let i = 0; i < 4; i++) {
        const craftingSlot = document.getElementsByClassName('crafting-slot2')[i];
        craftingSlot.innerHTML = '';
    }
updateCraftingItems2();
    updateInventory();
}
var itemsincrafting2=[null,null,null,null]
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
// Dodaj obsługę kraftowania przy kliknięciu w Crafting Table
function placeitemincraftingtable2(slotNumber) {
    const craftingSlot = document.getElementsByClassName('crafting-slot2')[slotNumber - 1];

    if (craftingSlot.innerHTML) {
      const itemName = items[currentitem][0];
        // Jeśli coś jest już umieszczone w crafting table, usuń to przy podwójnym kliknięciu
        addblock(craftingSlot.innerHTML.includes('alt') ? craftingSlot.querySelector('img').alt : null)
        craftingSlot.innerHTML = '';
      //  currentCraftingItem2 = null;
        updateCraftingItems2();
        
    } else {

   //     currentCraftingItem2 = items[currentitem][0];
        const itemName = items[currentitem][0];
        if(items[currentitem][1]>0){
        craftingSlot.innerHTML = `<img style="width: 100%; height: 100%;" src="./${items[currentitem][2]}" alt="${itemName}">`;
        subblock(itemName)
        updateCraftingItems2();
        }
    }
}

function updateCraftingItems2() {
    for (let i = 0; i < 4; i++) {
        const craftingSlot = document.getElementsByClassName('crafting-slot2')[i];
        itemsincrafting2[i] = craftingSlot.innerHTML.includes('alt') ? craftingSlot.querySelector('img').alt : null;
    }
    
}

// Dodaj przycisk do kraftowania


    </script>
</div>

</html>
