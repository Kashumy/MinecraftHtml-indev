
<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<html lang="en" onclick="openFullscreen()">

<div id="game-menu" class="none" style="position:fixed ;z-index:3; top:0;left:0;height:50vh;width:50vw;background : #CACACA6B ;color:white  ;font-size:24px; top:50vh; left :50vw; transform:translate(-50%,-50%);">

  <pre style="white-space :pre-wrap ">
 Workbench Classic Minecraft
 by: kashumyGithub
 orginal: mojang Minecraft 
</pre>
  <script>
    var isloading = 1
    var cloudsis = 1
var experiments={
  "test1":1,
}
    function openFullscreen() {
      var elem = document.documentElement;

      if (elem.requestFullscreen) {
        elem.requestFullscreen().then(rotateScreen);
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen().then(rotateScreen);
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen().then(rotateScreen);
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen().then(rotateScreen);
      }
      rotateScreen()
    }

    function rotateScreen() {
      if (screen.orientation) {

        screen.orientation.lock("landscape");
      }
    }
  </script>

</div>
<style>
  .alert2 {
    position: fixed;
    right: 20px;
    top: 20px;
    z-index: 2;
    width: 200px;
    height: 50px;
    background: #4C4C4C61;
    color: #FFFFFF;
  }
</style>
<script>
  function warn2(message) {
    var alertDiv = document.createElement("div");
    alertDiv.className = "alert2";
    alertDiv.innerHTML = message;

    document.body.appendChild(alertDiv);
    alertDiv.classList.add("show");

    setTimeout(function() {
      alertDiv.classList.remove("show");
      setTimeout(function() {
        alertDiv.remove();
      }, 300);
    }, 2000);
  }

  function menu_game() {
    document.getElementById('game-menu').classList.toggle('none')
  }
</script>

<style>
  .none {
    display: none;
  }
</style>

<head>

  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Menu</title>
  <style>
    dvt {
      position: fixed;
      background-image: url('./pobrane (7).png');
      background-size: 32px;
      background-repeat: repeat;
      filter: brightness(20%);
      width: 100%;
      height: 100vh;
      image-rendering: pixelated;
    }

    @font-face {
      font-family: 'mc';
      src: url('./Minecraft.ttf');
    }

    body {
      position: fixed;
      width: 100%;
      height: 100vh;
      background: #000000;
      margin: 0;
      padding: 0;

      font-family: "mc";
    }

    @media screen and (max-width: 769px) {
      dvt {}
    }

    .menu-container {
      text-align: center;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #42445A00;
      padding: 20px;
      border-radius: 10px;
    }

    .menu-button {
      display: block;
      background: url('./button.png');
      background-size: 100%;
      font-family: 'mc';

      background-repeat: no-repeat;
      width: 350px;
      padding: 10px;
      margin: 10px auto;

      color: white;
      text-decoration: none;

      font-size: 18px;
    }

    * {
      font-family: 'mc';
    }

    .menu-button:hover {}

    #logo {
      width: 100px;
      height: 100px;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      left: 50%;
      background-image: url('./cn.png');

    }

    .opct {
      opacity: 0;
      animation: opct 2s linear;
    }

    @keyframes opct {
      0% {
        opacity: 1;
      }

      100% {
        opacity: 0;
      }
    }
  </style>
</head>
<style>
  #splash {
    animation: buc 2s infinite;
    rotate: -10deg
  }

  @keyframes buc {
    0% {}

    50% {
      scale: 1.2
    }

    100% {
      scale: 1.0
    }
  }
</style>
<script>
  setTimeout(function() {
    var splashContainer = document.getElementById('splash');

    var splashes = [
"[ Object object ]",
"INDEV 0.5.2_pre_full",
" shiny GlowStone Gives light",
" You get Items in chest's ",
" warning Night is dangerous ",
" Build House In NIGHT !"
  ];

    for (var i = 0; i < 20; i++) {
      var randomIndex = Math.floor(Math.random() * splashes.length);
      var splashText = splashes[randomIndex];

      var splashDiv = document.createElement('div');
      splashDiv.className = 'splash';
      splashDiv.textContent = splashText;

      splashContainer.innerHTML = splashDiv.innerText;
    }
  }, 3000);
</script>

<body>
  <dvt></dvt>

  <div id="ss" style="position:fixed ;z-index:3; top:0;left:0;height:100vh;width:100vw;background :white ;color:black ;font-size:4px; ">

    <img src="./cn.png" id="logo">
  </div>

  <div class="menu-container">
    <div style="position: absolute; top:0; left:0;"> indev 0.5.2 pre 3 </div>
    <img src="./Workbench.png" style="width :390px" alt="">
 <div id="splash" style="color :yellow; margin-top :-30px; margin-left :250px">
      Now on mobile
    </div>
    <a class="menu-button" onclick="play()">Play</a>
    <a class="menu-button" href="#">Options</a>
    <a class="menu-button" href="#">Exit Game</a>

  </div>
  <div style="position :fixed ; bottom :0px ; left :0px; color :white ;">
    Consout Copyright Â© You can distribute
  </div>
</body>

</html>
<script>
  if (isloading == 1) {
    setTimeout(function() {
      document.getElementById('ss').classList.add('opct')
      setTimeout(function() {
        document.getElementById('ss').style.display = "none"
      }, 2000)
    }, 6000)
  } else {
    setTimeout(function() {
      document.getElementById('ss').classList.add('opct')
      setTimeout(function() {
        document.getElementById('ss').style.display = "none"
      }, 2000)

    }, 100)
  }
  var lbar = document.getElementById('lbar')
  var progress = 0

  function playworld(data) {

    lbar = document.getElementById('lbar')
    document.querySelector('.menu').style.display = "none"
    document.getElementById('lading').style.display = "block"
    var max = 100;

    for (var i = 0; i <= max; i++) {
      (function(i) {
        setTimeout(function() {
          progress += 1
          lbar.style.width = progress + "%"
        }, i * 100);
      })(i);
    }

    if (isloading == 1) {
      setTimeout(function() {
        if (data == "world1") {
          document.getElementById('game-container').style.display = "block"
Start()
        }
      }, 13000)
    } else {
      if (data == "world1") {
        document.getElementById('game-container').style.display = "block"
        Start()
      }
    }

  }
  if (isloading == 1) {
    setTimeout(function() {
      document.getElementById('game-container').style.display = "none"
    }, 4000)
  }

  function play() {
    document.querySelector('.mmenu').style.display = "block"
  }

  function canel() {
    document.querySelector('.mmenu').style.display = "none"
  }
</script>
<div class="mmenu">

  <div id="lading" style="width :100%;height :100vh; display :none; position :absolute ">

    <pre style="color :white ; text-align :center ;position :absolute; transform:translate(-50%,-50%); top:calc(50vh - 60px); left :50vw;">Building terrain</pre>
    <div id="" style="width :200px;height :10px; position :absolute; transform:translate(-50%,-50%); top:50vh; left :50vw; background-color :gray ">

      <div id="lbar" style="width :0%; background :lime ; height :100%; filter :brightness(1.0)">

      </div>
    </div>

  </div>
  <div class="menu">

    <div onclick="playworld('world1')">world1</div>
    <div class="bt" id="bt" style="width :200px" onclick="canel()">canel</div>

  </div>
</div>

<style>
  #game-container {}

  .dead {
    animation: 0.15s dmg steps(1), 0.3s rtt;

  }

  @keyframes dmg {
    0% {
      filter: hue-rotate(-100deg);
      scale: 2.6
    }
  }

  @keyframes rtt {
    0% {
      scale: 2.0
    }

    50% {
      rotate: -5deg
    }

    100% {
      rotate: 5deg scale:1.5
    }
  }

  .menu {
    position: fixed;
    overflow: hidden;
    overflow: scroll;
    top: 50vh;
    left: 50vw;
    background: #0F0F0F80;
    transform: translate(-50%, -50%);
    width: 80%;
    padding: 10px;
    height: calc(50vh + 100px);
  }

  .menu div {
    width: calc(100% - 10px);
    background: url('./button.png');
    background-size: 100%;
    background-repeat: no-repeat;
    padding: 5px;
    margin-bottom: 5px;
    color: white;
    font-weight: bold;
    text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
    font-family: 'mc';
    height: 30px;

  }

  #bt {
    position: fixed;
    left: 20px;
    bottom: 0px
  }

  .bt {
    width: 40px;
    background: #747474;
    padding: 10px;
    background-size: 100%;
    background-repeat: no-repeat;
    padding: 5px;
    margin-bottom: 5px;
    color: #FFFFFF;
    font-weight: bold;
    text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
    font-family: 'mc';
    font-size: 13px;
    background-repeat: no-repeat;

  }

  .mmenu {
    position: fixed;
    display: none;
    width: 100%;
    height: 100%;
    background: url('./pobrane (8).png');
    background-size: 40px;
    image-rendering: pixelated;
    filter: brightness(0.5);
  }
</style>

<style>
  html {
    position: fixed;
    width: 100%;
    height: 100vh;
    user-select: none;
    user-zoom: none;
    min-zoom: 1;
    max-zoom: 1;
    margin: 0;
    padding: 0;
  }

  .item-slot {
    width: 50px;
    height: 50px;
    background: url('./itemslot.png');
    float: left;
    background-size: 100%;
    image-rendering: pixelated;
    margin-left: 3px;
    transition: background-color 0.3s ease;
  }

  .item-slot:hover {
    background: #f0f0f0;
  }

  #items {
    width: 370px;
    height: 100px;
    position: absolute;
    bottom: -10px;
    overflow: hidden;
    overflow: scroll;
    left: 55vw;
    background: #1E1E1E2E;
    transform: translate(-50%, 0%);
    z-index: 1;
  }

  body {}

  #game {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    background: #87CEEB;
    filter: saturate(96%) brightness(96%) contrast(90%) sepia(20%) grayscale(0%) invert(5%) hue-rotate(0deg);

  }

  #controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 2;
    width: 200px;
    overflow: hidden;
    zoom: 0.8
  }

  .null {
    user-select: none;
    width: 50px;
    margin: 5px;
    height: 50px;
    background: #42445A00;
    color: #FFFFFF;
    float: left;
  }

  button {
    margin: 5px;
  }

  .btn {
    border: 0px solid #626262;
    user-select: none;
    width: 50px;
    background: url('./btn.png');
    float: left;
    height: 50px;

    color: #FFFFFF;
  }

  #debug {
    width: 90px;
    height: 5px;
    padding: 10px;
    background: #FCFCFC6E;
    position: fixed;
    z-index: 9;
    bottom: 0;
    left: 0;
  }
</style>
</head>
<div id="debug">
  x:<t id="xpos"></t>y:<t id="ypos"></t>z:<t id="zpos"></t>
</div>
<div id="game-container">

  <div id="fps-counter" style="position: fixed ; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.5); color: white; padding: 5px; z-index :999"></div>
  <div id="items">
    <div id="hearts">
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>
      <div class="heart"></div>

    </div>
    <style>
      #hearts {
        width: 100%;
        height: 20px;

      }

      .heart {
        background-image: url('./heart.png');
        width: 20px;
        margin-left: -5px;
        height: 20px;
        float: left;
        image-rendering: pixelated;
        background-size: 100%;
      }

      .night {
        background-color: #000000;
        animation: nights 35s forwards steps(30);
      }

      .day {
        background-color: #53D8F0;
        animation: days 35s forwards steps(30);
      }

      @keyframes nights {
        0.1% {
          background: #87CEEB;
        }

        30% {
          background: linear-gradient(#3988A2, #EBAF1A);
        }

        50% {
          background: #0E4E69;
        }

        80% {
          background: #07244F;
        }

        100% {
          background: #000000;
        }
      }

      @keyframes days {
        0.1% {
          background: #000000;
        }

        20% {
          background: #07244F;
        }

        50% {
          background: #0E4E69;
        }

        70% {
          background: #3983A2;
        }

        99.9% {
          background: #87CEEB;
        }

        100% {
          background: #000000;
        }
      }
    </style>
    <div class="item-slot" onclick="switchi('pickaxe')"><img style="width:60%;height :60%;margin :20%" src="./pickaxe.png" alt=""></div>
  </div>

    <script type="module">

      import * as THREE from "./three.module.js"; 
      import { GLTFLoader } from "./GLTFLoader(1).js"; 
window.THREE = THREE;
window.GLTFLoader = GLTFLoader;
</script>

    <script>

setTimeout(function(){

        
        function Slider(config) {
          this.name = config.name;
            this.min = config.min;
            this.max = config.max;
            this.addby = config.addby;
            this.variable = config.variable;
        }

        
        function appendslider(slider, elementId) {
            var element = document.querySelector(elementId);
var sliderName = document.createElement("div");
sliderName.innerText=slider.name

            
            var sliderElement = document.createElement("input");
            sliderElement.type = "range";
            sliderElement.min = slider.min;
            sliderElement.max = slider.max;
            sliderElement.step = slider.addby;

            
            sliderElement.addEventListener("input", function() {
                
                warn2(sliderElement.value)
                window[slider.variable]  = parseFloat(sliderElement.value);

                console.log("Nowa wartoÅÄ zmiennej:", window[slider.variable]  );
                defrdist=rdist
            });

            

            element.appendChild(sliderName);
            element.appendChild(sliderElement);
        }

var Slider1 = new Slider({'name':"chunk size" ,'min': 10, 'max': 30, 'addby': 2, 'variable': 'rdistD'});
appendslider(Slider1, ".menu");

var Slider2a = new Slider({ 'name': "number of terrain's ", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numberterains1D' });
appendslider(Slider2a, ".menu");

var Slider3a = new Slider({ 'name': "Heigh Terrain", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numofcirclesD' });
appendslider(Slider3a, ".menu");

var Slider4a = new Slider({ 'name': "Number of Trees", 'min': 0, 'max': 5, 'addby': 1, 'variable': 'numberOfTreesD' });
appendslider(Slider4a, ".menu");

},Infinity);

    var cantbuildthisblockGeometry = 0;
    var items = {
      "1": ["stone", 0, "./pobrane (14).png"],
      "2": ["grass", 0, "./pobrane (9).png"],
      "3": ["wood", 0, "./pobrane (10).png"],
      "4": ["water", 0, "./water.png", "water2"],
      "5": ["leaves", 0, "./pobrane (19).png"],
      "6": ["brick", 0, "./pobrane (12).png"],
      "7": ["glass", 0, "./glass.png"],
      "8": ["glowstone", 0, "./glowstone.png"],
      "9": ["polishedstone", 0, "./pobrane (11).png"]
    };
    var nocollisions = ["water"]

    function createItemSlots() {
      const itemSlotsContainer = document.getElementById('items');

      const maxSlots = Math.min(20, Object.keys(items).length);

      for (let i = 1; i <= maxSlots; i++) {
        const itemInfo = items[i.toString()];
        const [itemName, itemCount, itemImage] = itemInfo;

        const itemSlot = document.createElement('div');
        itemSlot.className = 'item-slot';
        itemSlot.style.position = 'relative';
        itemSlot.id = `itemslot${i}`

        itemSlot.innerHTML = `
           <img style="width:60%;height:60%;margin:20%" src="${itemImage}"  alt="">
           <p id="items-slot-${i}" style="position:absolute;top:0%;z-index:99;left:0%;color:white">x${itemCount}</p>
         `;
        itemSlot.addEventListener('click', function() {
          switchi(itemName);
        });

        itemSlotsContainer.appendChild(itemSlot);
      }
    }

    window.addEventListener('load', createItemSlots);

    function checkItemSlotsForItems() {
      const itemSlotsContainer = document.getElementById('items');

      setInterval(() => {
        for (let i = 1; i <= Object.keys(items).length; i++) {
          const itemInfo = items[i.toString()];
          const [itemName, itemCount] = itemInfo;
          const itemSlot = document.getElementById(`itemslot${i}`);

          if (itemCount < 1) {

            itemSlot.style.display = 'none';
          } else {

            itemSlot.style.display = 'block';

          }
        }
      }, 1000);
    }

    window.addEventListener('load', checkItemSlotsForItems);

    var currentitemslot = '';

    function updateInventory() {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          var item = items[key];
          var itemName = item[0];
          var itemCount = item[1];
          var slotId = "items-slot-" + key;
          var slotElement = document.getElementById(slotId);
          if (slotElement) {
            slotElement.textContent = "x" + itemCount;
          }

        }
      }
      checkItm(currentitemslot)
    }

    function addblock(typ3) {
      var searchedItem = typ3;
      var index = -1;

      for (var key in items) {
        if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
          index = key;
          break;
        }
      }
      items[index][1] += 1
      updateInventory()
    }

    function useblock(typ3) {

      items[typ3][1] -= 1

      updateInventory()

    }

    function checkItm(typ3) {
      var searchedItem = currentitemslot;
      var index = -1;

      for (var key in items) {
        if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
          index = key;
          if (items[index][1] < 1) {
            cantbuildthisblockGeometry = 1
          } else {
            cantbuildthisblockGeometry = 0
          }
          break;
        }
      }

    }
    updateInventory()
  </script>

  <img src="./croschair.png" style="position :fixed ; transform:translate(-50%,-50%); top:50vh ;left :50vw; z-index :1">

  <div id="game2" style="position:absolute;background: black; width:100%; height:100vh;">
  </div>
  <canvas id="game"></canvas>
  <div id="controls">
    <div class="null"></div>
    <button id="moveForward" class="btn"></button>
    <div class="null"></div>
    <button id="moveLeft" class="btn"></button>
    <div class="null"></div>

    <button id="moveRight" class="btn"></button>
    <div class="null"></div>
    <button id="moveBackward" class="btn"></button>

  </div>
  <button id="jump" style="position :fixed ; z-index: 2; right :50px; bottom: 20px" class="btn"></button>
  <button id="empty"  onclick="menu_game()" style="position :fixed ; right :0px; top: 50px ; font-weight :bold " class="btn">|&nbsp;&nbsp;|</button>

</div>

<script>

var numberOfTreesD = 3;
var numofcirclesD = 1
var numberterains1D = 2
var rdistD = 13
var defrdistD = 10

var switchi;

 function Start() {

setTimeout( function() {

var steponstone = 0
  var fpsCounter = document.getElementById('fps-counter');

  var frameCount = 0;
  var lastTime;
  var fps;

  function updateFPS() {
    var currentTime = performance.now();
    frameCount++;

    if (!lastTime) {
      lastTime = currentTime;
      return;
    }

    var elapsedMilliseconds = currentTime - lastTime;

    if (elapsedMilliseconds >= 1000) {
      fps = Math.round((frameCount * 1000) / elapsedMilliseconds);
      fpsCounter.innerHTML = 'FPS: ' + fps;
      frameCount = 0;
      lastTime = currentTime;
    }
  }

  let defaultFps = 30
  let targetFPS = 25;
  let frameTime = 1000 / targetFPS;

  const scene = new THREE.Scene();

  var canv = document.getElementById("game");
  var width = canv.clientWidth;
  var height = canv.clientHeight;

  const camera = new THREE.PerspectiveCamera(
    90,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  var renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("game"), alpha: true, antialias: true });



renderer.gammaFactor = 0.2;  


renderer.toneMappingExposure = 0.3;




  var lod = new THREE.LOD();

  renderer.setSize(window.innerWidth, window.innerHeight);

  
var ambientLight=new THREE.AmbientLight(0x707070)
  scene.add(ambientLight);

  const light = new THREE.DirectionalLight(0xffffff, 0.60);
  light.position.set(0, 2, 0);

  scene.add(light);

 

  scene.fog = new THREE.FogExp2(0xffffff, 0.009);

  const playerGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
  const playerMaterial = new THREE.MeshStandardMaterial({ color: 0x00000000, transparent: true, opacity: 0.0 });
  const player = new THREE.Mesh(playerGeometry, playerMaterial);
  scene.add(player);

  var textureLoader = new THREE.TextureLoader();
  const texture = textureLoader.load('./pobrane (12).png');

  const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

  var textureTop = new THREE.TextureLoader().load('./grass.png');
textureTop.magFilter = THREE.NearestFilter;
textureTop.minFilter = THREE.NearestFilter;

  var textureBottom = new THREE.TextureLoader().load('./pobrane (8).png');
  textureBottom.magFilter = THREE.NearestFilter;
  textureBottom.minFilter = THREE.NearestFilter;
  var textureSides = new THREE.TextureLoader().load('./front2.png');
  textureSides.magFilter = THREE.NearestFilter;
  textureSides.minFilter = THREE.NearestFilter;
  var water = new THREE.TextureLoader().load('./water.png');

  var textureSides2 = new THREE.TextureLoader().load('./pobrane (13).png');
  textureSides2.magFilter = THREE.NearestFilter;
  textureSides2.minFilter = THREE.NearestFilter;
  var wood = new THREE.TextureLoader().load('./cobble.png');
  var stone1 = new THREE.TextureLoader().load('./pobrane (7).png');
  var stone3 = new THREE.TextureLoader().load('./pobrane (10).png');
  var wood1 = new THREE.TextureLoader().load('./pobrane (16).png');
  var leaves = new THREE.TextureLoader().load('./pobrane (19).png');
  leaves.magFilter = THREE.NearestFilter;
  leaves.minFilter = THREE.NearestFilter;
  wood1.magFilter = THREE.NearestFilter;
  wood1.minFilter = THREE.NearestFilter;
  stone1.magFilter = THREE.NearestFilter;
  stone1.minFilter = THREE.NearestFilter;
  stone3.magFilter = THREE.NearestFilter;
  stone3.minFilter = THREE.NearestFilter;
  var chet1 = new THREE.TextureLoader().load('./chest_front.png');
  chet1.magFilter = THREE.NearestFilter;
  chet1.minFilter = THREE.NearestFilter;
  var chest = new THREE.MeshStandardMaterial({ map: chet1, });

  var water2 = new THREE.MeshStandardMaterial({ map: water,  transparent: true, opacity: 0.9 });
  var stone = new THREE.MeshStandardMaterial({ map: stone1, });

  var wooden = new THREE.MeshStandardMaterial({ map: wood, });
  var stonen = new THREE.MeshStandardMaterial({ map: stone3,  });
  var material2 = new THREE.MeshStandardMaterial({ map: textureSides2,  });
  var materialTop = new THREE.MeshStandardMaterial({ map: textureTop, transparent: true, opacity: 1 });
  var materialBottom = new THREE.MeshStandardMaterial({ map: textureBottom,  });
  var materialSides = new THREE.MeshStandardMaterial({ map: textureSides,});

  const blockMaterial = new THREE.MeshLambertMaterial({ map: texture,  });

  var materials = [
  materialSides,
  materialSides,
  materialTop,
  materialBottom,
  materialSides,
  materialSides,

];

  var blocks = [];
  var renderingdist = 6

  var chunks = [];
  var rdist = rdistD

  function checkAndRemoveDuplicateBlocks(currentChunkX, currentChunkZ) {
    const radius = rdist;

    const blocksToRemove = [];

    for (let i = 0; i < blocks.length; i++) {
      const blockA = blocks[i];

      const distance = camera.position.distanceTo(blockA.position);

      if (distance <= radius) {
        const blockChunkX = Math.floor(blockA.position.x / rdist);
        const blockChunkZ = Math.floor(blockA.position.z / rdist);

        if (blockChunkX === currentChunkX && blockChunkZ === currentChunkZ) {
          for (let j = i + 1; j < blocks.length; j++) {
            const blockB = blocks[j];

            if (
              blockA.position.x === blockB.position.x &&
              blockA.position.y === blockB.position.y &&
              blockA.position.z === blockB.position.z
            ) {
              blocksToRemove.push(blockB);
            }
          }
        }
      }
    }

    blocksToRemove.forEach((block) => {
      scene.remove(block);
      const index = blocks.indexOf(block);
      if (index !== -1) {
        blocks.splice(index, 1);
      }
    });

    targetFPS = defaultFps;
    frameTime = 1000 / targetFPS;
  }

  function removeBlocksNearCamera() {
    const radius = 200;

    const blocksToRemove = blocks.filter((block) => {
      const distance = camera.position.distanceTo(block.position);
      return distance <= radius;
    });

    blocksToRemove.forEach((block) => {
      scene.remove(block);
      const index = blocks.indexOf(block);
      if (index !== -1) {

      }
    });
  }
  var worldFlat = 0
  var chunkX = 0
  var chunkZ = 0

  function generateChunk(x, z) {
    chunkX = x
    chunkZ = z

    targetFPS = 10;
    frameTime = 1000 / targetFPS;
    removeBlocksNearCamera()


    const chunk = new THREE.Group();

    const layerHeight = -3;
    const voxelSize = 1;
    const gridSize = 20;
    var numCircles = numofcirclesD;
    const fillRadius = 0;

    const voxelsize2 = 1;
    const gridsize2 = 20;
    const fillRadius2 = 0;

    const voxelCoordinates = [
            [0, 0, 0],
            [1, 0, 0],

            [2, 0, 1],
            [2, 0, 2],
            [1, 0, 2],
            [0, 0, 2],
            [2, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [1, 1, 0],

            [2, 1, 1],
            [2, 1, 2],
            [1, 1, 2],
            [0, 1, 2],
            [2, 1, 0],
            [0, 1, 1],
            [1, 2, 0],
            [1, 2, 1],
            [2, 2, 1],
            [1, 2, 2],
            [0, 2, 1],
[1, 1, 1, 1],
[1, 0, 1, 1],
[1, -1, 1, 1],
[1, -2, 1, 1]

        ];

    let randomz = Math.floor(Math.random() * 20) 
    let randomx = Math.floor(Math.random() * 20) 
    var trees = 0;
    const numberOfTrees = numberOfTreesD;
    if (worldFlat == 0) {
      for (let i = 0; i < numberOfTrees; i++) {
        const randomx = Math.floor(Math.random() * rdist);
        const randomz = Math.floor(Math.random() * rdist) ;

        voxelCoordinates.forEach(coords => {
          const [x2, y2, z2, type] = coords;
          let material = new THREE.MeshStandardMaterial({ map: leaves});
          if (type === 1) {
            material = new THREE.MeshStandardMaterial({ map: wood1});
          }

          const block = new THREE.Mesh(new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize), material);
          block.position.set(x2 + randomx + x * rdist, y2, z2 + randomz + z * rdist);
          block.name = 'leaves'
          if (type == 1) {
            block.name = 'woodblock'
          }

          blocks.push(block);

        });
      }
    }
    let numOfterains1 = Math.floor(Math.random() * numberterains1D)
    if (worldFlat == 0) {
      for (let j2 = 0; j2 < numOfterains1; j2++) {
        let randomXZ = Math.floor(Math.random() * rdist)
        let randomZX = Math.floor(Math.random() * rdist)
        numCircles = Math.floor(Math.random() * 3) + 4
        for (var m = -2; m < Math.floor(2); m++) {
          numCircles -= 1
          const dwn = m
          for (let i = 0; i < numCircles; i++) {
            const radius = (Math.random() * 0.5) + i;
            const segments = 64;

            for (let j = 0; j < segments; j++) {
              const angle = (j / segments) * Math.PI * 2;
              const xv = (Math.cos(angle) * radius) + (x * rdist);
              const zv = (Math.sin(angle) * radius) + (z * rdist);
              const yv = -2;

              const distanceToCenter = Math.sqrt(xv * xv + zv * zv);

              if (distanceToCenter > fillRadius) {
                const block = new THREE.Mesh(blockGeometry, materials);
                block.position.set(Math.floor(xv) + randomXZ, dwn, Math.floor(zv) + randomZX);

                block.name = 'grass'
                blocks.push(block)

              }
            }
          }
        }
      }
    }
    for (let x2 = 0; x2 < rdist; x2++) {
      for (let z2 = 0; z2 < rdist; z2++) {

        if (Math.floor(Math.random() * 30) == 1) {
          let block = new THREE.Mesh(blockGeometry, materials);
          block.name = 'grass'
          block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);

          blocks.push(block);

        } else {
          if (Math.floor(Math.random() * 20) == 3) {
            let block = new THREE.Mesh(blockGeometry, water2);

            block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);

            block.name = 'water'

            blocks.push(block);

          } else {
            let block = new THREE.Mesh(blockGeometry, materials);

            block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist);

            block.name = 'grass'
            blocks.push(block);

          }
          if (Math.floor(Math.random() * 155) == 5) {
            block = new THREE.Mesh(blockGeometry, chest);
            block.name = 'chest'
            block.position.set(x2 + x * rdist, layerHeight + 1, z2 + z * rdist);

            blocks.push(block);
          }
        }

      }

    }

    for (let x2 = 0; x2 < rdist; x2++) {
      for (let y2 = 0; y2 < 2; y2++)
        for (let z2 = 0; z2 < rdist; z2++) {

          if (Math.floor(Math.random() * 15) == 3) {
            var block = new THREE.Mesh(blockGeometry, materials);
            var itemTexture = new THREE.TextureLoader().load('./pobrane (12).png');
            itemTexture.magFilter = THREE.NearestFilter;
            itemTexture.minFilter = THREE.NearestFilter;
            var itemMaterial = new THREE.MeshStandardMaterial({ map: itemTexture });
            block.material = itemMaterial;
            block.name = "brick"

          } else {
            var block = new THREE.Mesh(blockGeometry, stone);
            block.name = 'stone'
          }

          block.position.set(x2 + x * rdist, -4 -
            y2, z2 + z * rdist);

          blocks.push(block);

        }
    }

    chunks.push({ x, z, chunk });
    generateChunkinprocess_Cave(x, z)

    setTimeout(function() {
      checkAndRemoveDuplicateBlocks(x, z)
      renderingdist = 6
    }, 4000)
  }

  const frustum = new THREE.Frustum();

  function updateFrustum() {
    camera.updateMatrixWorld();
    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
  }

  function isObjectVisible(object) {
    return frustum.intersectsObject(object);
  }
  let renderDistance = 3

  function isBlockVisible(block) {
    const distance = camera.position.distanceTo(block.position);
    return distance < renderDistance;
  }
  const blocksInCave = [];

  var gins = 0

  function generateChunkinprocess_Cave(x, z) {

    const chunk = new THREE.Group();

    const startHeight = -6;

    const endHeight = -22;

    let layerHeight = startHeight;
    let x2 = 0;
    let z2 = 0;

    function generateLayer() {

      for (let y = 0; y < 2; y++) {
        for (let i = 0; i < rdist; i++) {

          if (layerHeight > endHeight) {

            const block = new THREE.Mesh(blockGeometry, stone);
            block.position.set(x2 + x * rdist, layerHeight , z2 + z * rdist);

            block.name = "stone"
            if (Math.floor(Math.random() * 200) == 5) {
              var itemTexture = new THREE.TextureLoader().load("./pobrane (11).png");
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshStandardMaterial({ map: itemTexture, transparent: true, alpha: true });
              block.material = itemMaterial;
              block.name = "polishedstone"
            }

            blocks.push(block);
            blocksInCave.push(block);

            x2++;
            if (x2 >= rdist) {
              x2 = 0;
              z2++;
              if (z2 >= rdist) {
                z2 = 0;
                layerHeight--;
              }
            }
          }
        }

      }

      if (layerHeight > -10) {
        requestAnimationFrame(generateLayer);

      }

    }

    generateLayer();

    chunks.push({ x, z, chunk });
  }

  function updateOcclusionCulling() {

  }

  function updateBlockfaceCulling() {

  }

  var visibleblocks = []

  function scheduleRandomExecution() {
    const minInterval = 5000;
    const maxInterval = 60000;

    const randomInterval = Math.random() * (maxInterval - minInterval) + minInterval;

  }

  scheduleRandomExecution();

  const occlusionRadius = 2;

  function updaterenderdistance(playerChunkX, playerChunkZ) {
    const occlusionRadius = renderingdist;
    const additionalDistance = 3;

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
    });

    blocksInCurrentChunk.forEach(block => {
      const distance = camera.position.distanceTo(block.position);

      if (distance <= occlusionRadius + additionalDistance) {
        if (distance <= occlusionRadius) {

          if (!scene.children.includes(block)) {
            scene.add(block);

          }
        } else {

          if (scene.children.includes(block)) {
            scene.remove(block);
          }
        }
      } else {

      }
    });
  }

  let one = 0

  function updatePlayerChunk() {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);

    if (!chunks.some(chunk => chunk.x === playerChunkX && chunk.z === playerChunkZ)) {

      for (let i = chunks.length - 1; i >= 0; i--) {
      
      }

      generateChunk(playerChunkX, playerChunkZ);
      player.position.y = 4

    }
  }

  const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
  const skyMaterial = new THREE.MeshStandardMaterial({ color: 0x87EEEB, side: THREE.BackSide });
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);


  const clouds = [];
  if (cloudsis == 1) {
    for (let i = 0; i < 200; i++) {
      const cloudGeometry = new THREE.BoxGeometry(Math.random() * 10 + 15, 0, Math.random() * 10 + 10);
      const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud.position.set(Math.random() * 400 - 150, 15, Math.random() * 500 - 150);
      clouds.push(cloud);
      scene.add(cloud);
    }
  }

  camera.position.z = -15;
  camera.position.y = 1;
  camera.rotation.order = 'YXZ';

  const gravity = new THREE.Vector3(0, -0.045, 0);
  const playerVelocity = new THREE.Vector3();
  setTimeout(function() {

    player.position.y = 10
    player.position.x = 5
  player.position.z = 5
    playerVelocity.set(0, 0, 0);
    setTimeout(function() {

      player.position.y = 10
      player.position.x = 5
      player.position.z = 5
      playerVelocity.set(0, 0, 0);

    }, 1000)
  }, 2100)

  const playerSpeed = 0.3;

  const moveForwardButton = document.getElementById('moveForward');
  const moveBackwardButton = document.getElementById('moveBackward');
  const moveLeftButton = document.getElementById('moveLeft');
  const moveRightButton = document.getElementById('moveRight');
  const jumpButton = document.getElementById('jump');

  let forwardPressed = false;
  let backwardPressed = false;
  let leftPressed = false;
  let rightPressed = false;
  let jumpPressed = false;

  moveForwardButton.addEventListener('touchstart', () => {
    forwardPressed = true;
  });
  moveForwardButton.addEventListener('touchend', () => {
    forwardPressed = false;
  });

  moveBackwardButton.addEventListener('touchstart', () => {
    backwardPressed = true;
  });
  moveBackwardButton.addEventListener('touchend', () => {
    backwardPressed = false;
  });

  moveLeftButton.addEventListener('touchstart', () => {
    leftPressed = true;
  });
  moveLeftButton.addEventListener('touchend', () => {
    leftPressed = false;
  });

  moveRightButton.addEventListener('touchstart', () => {
    rightPressed = true;
  });
  moveRightButton.addEventListener('touchend', () => {
    rightPressed = false;
  });
  var cantjump = 0
  var jumping = 1
  jumpButton.addEventListener('touchstart', (event) => {
    event.preventDefault()
    if (cantjump == 0) {
      jumpposition = player.position.y
      jumpPressed = true;
    } else if (jumping > 0) {
      jumpposition = player.position.y
      jumpPressed = true;
      jumping = -1
    }
  });
  jumpButton.addEventListener('click', (event) => {
    event.preventDefault()
    if (cantjump == 0) {
      jumpposition = player.position.y
      jumpPressed = true;
    } else if (jumping > 0) {
      jumpposition = player.position.y
      jumpPressed = true;
      jumping = -1
    }

  });

  const stopMovement = () => {
    playerVelocity.set(0, 0, 0);

  };
  var Movementspeed = 0.24;

  var jumpposition = 0
  var fallingdmgisactive = 0;
  setTimeout(function() {
    fallingdmgisactive = 1
  }, 6000)
  let forwalking = 0
  let D20times = 0
  let D5times

  const creepers = [];

  const handleCollisions = (object, blocks) => {
    const objectBox = new THREE.Box3().setFromObject(object);

    for (const block of blocks) {
      const blockBox = new THREE.Box3().setFromObject(block);

      if (!nocollisions.includes(block.name)) {
        const halfWallHeight = block.geometry.parameters.height / 2.0;
        const halfWallDepth = block.geometry.parameters.depth / 2.8;
        const halfWallWidth = block.geometry.parameters.width / 2.8;

        if (
          object.position.x - 0.5 < block.position.x + halfWallWidth &&
          object.position.x > block.position.x &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          object.position.x += 0.3;
        }

        if (
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x < block.position.x &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          object.position.x -= 0.3;
        }

        if (
          object.position.z - 0.5 < block.position.z + halfWallDepth &&
          object.position.z > block.position.z &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          object.position.z += 0.3;
        }

        if (
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z < block.position.z &&
          object.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          object.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          object.position.z -= 0.3;
        }

        if (
          object.position.y - 0.5 < block.position.y + halfWallHeight &&
          object.position.y > block.position.y  &&
          object.position.x + 0.5 > block.position.x - halfWallWidth &&
          object.position.x - 0.5 < block.position.x + halfWallWidth &&
          object.position.z + 0.5 > block.position.z - halfWallDepth &&
          object.position.z - 0.5 < block.position.z + halfWallDepth
        ) {

          object.position.y += 0.2;
const distanceToPlayer = object.position.distanceTo(player.position);

if (distanceToPlayer <= 5) {

  const playerDirection = new THREE.Vector3().copy(player.position).sub(object.position);
  playerDirection.y = object.position.y;
  playerDirection.normalize();

  const speed = 0.10;
  object.position.add(playerDirection.multiplyScalar(speed));
}
        } else if (!(object.position.y - 0.8 < block.position.y + halfWallHeight &&
            object.position.y > block.position.y &&
            object.position.x + 0.5 > block.position.x - halfWallWidth &&
            object.position.x - 0.5 < block.position.x + halfWallWidth &&
            object.position.z + 0.5 > block.position.z - halfWallDepth &&
            object.position.z - 0.5 < block.position.z + halfWallDepth)) {

        }

      }
    }
  };
  let ghs = 0

  function OneHurt() {
    if (ghs == 0) {
      ghs = 1
      hurt()
      hurt()
      setTimeout(hurt,500)
      setTimeout(function() {
        hurt()
        ghs = 0
      }, 1000)
    }
  }

  let LplayerChunkX = Math.floor(player.position.x / rdist);
  let LplayerChunkZ = Math.floor(player.position.z / rdist);

  let creeperVelocity = 0.05

  const animate = () => {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);

    LplayerChunkX = Math.floor(player.position.x / rdist);
    LplayerChunkZ = Math.floor(player.position.z / rdist);

    if (D5times < 1) {
      D5times++
    } else {

      updaterenderdistance(playerChunkX, playerChunkZ)
      D5times=0
    }
    if (D20times < 10) {

      D20times++
    } else {
      D20times = 0
      updatePlayerChunk()
    }

    if (player.position.y < -100) {
      player.position.y = 20
    }
    document.getElementById("xpos").innerHTML = Math.floor(camera.position.x)
    document.getElementById("ypos").innerHTML = Math.floor(camera.position.y)
    document.getElementById("zpos").innerHTML = Math.floor(camera.position.z)
    updateFPS();
    setTimeout(() => {
     requestAnimationFrame(animate);
    }, frameTime);

    camera.position.set(player.position.x, player.position.y + 1.3, player.position.z);
    camera.rotation.order = 'YXZ';

    playerVelocity.add(gravity);

    const playerVelocity2 = new THREE.Vector3(0, 0, 0);

    if (forwardPressed) {

      const speed = Movementspeed;
      if (forwalking < 5) {
        forwalking++
      } else {
        var audio = new Audio('./grass1.ogg');
        forwalking = 0

        audio.play();
      }

      const direction = new THREE.Vector3(0, 0, -1.5);
      direction.applyQuaternion(camera.quaternion).normalize();

      const playerVelocity2 = new THREE.Vector3(direction.x * speed, 0, direction.z * speed);

      player.position.add(playerVelocity2);

    }

    else if (backwardPressed) {
      camera.translateZ(Movementspeed);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else {
      playerVelocity.z = 0;
    }

    if (leftPressed) {
      camera.translateX(Movementspeed * -1);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else if (rightPressed) {
      camera.translateX(Movementspeed);
      player.position.z = camera.position.z
      player.position.x = camera.position.x
    } else {
      playerVelocity.x = 0;
    }

    if (jumpPressed) {
      playerVelocity.y = 0.30;
      jumpPressed = false;
    }

    player.position.add(playerVelocity);

    const halfPlayerWidth = 0.5;
    const halfPlayerHeight = 0.4;
    const halfPlayerDepth = 0.5;

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
    });

    creepers.forEach(creeper => {

      if (!creeper.wanderTimer) {
        creeper.wanderTimer = 0;
        creeper.wanderDuration = 4;
        creeper.inAttackRange = false;
      }

      const distanceToPlayer = creeper.position.distanceTo(player.position);
      if (creeper.position.y <= -30) {
        scene.remove(creeper);

        const index = creepers.indexOf(creeper);
        if (index !== -1) {
          creepers.splice(index, 1);
        }
        return 0;
      } else
      if (distanceToPlayer <= 1) {
        scene.remove(creeper);

        const index = creepers.indexOf(creeper);
        if (index !== -1) {
          creepers.splice(index, 1);
        }

        OneHurt()
        return 0;
      } else {
        if (distanceToPlayer <= 5) {

          creeper.inAttackRange = true;
        } else {

        }
        if (!(distanceToPlayer <= 1)) {
          creeper.position.y -= 0.2;
          handleCollisions(creeper, blocksInCurrentChunk);
        }

      }
      if (distanceToPlayer < 7) {
        creeper.lookAt(player.position.x * -1, creeper.position.y, player.position.z * -1)

      }
    });

    for (const block of blocksInCurrentChunk) {
      const box1 = new THREE.Box3().setFromObject(player);
      const box2 = new THREE.Box3().setFromObject(block);

      if (box1.intersectsBox(box2)) {

      }
      if (!nocollisions.includes(block.name)) {

        const halfWallHeight = block.geometry.parameters.height / 2.0;
        const halfWallDepth = block.geometry.parameters.depth / 2.8;
        const halfWallWidth = block.geometry.parameters.width / 2.8;

        if (
          player.position.x - 0.5 < block.position.x + halfWallWidth &&
          player.position.x > block.position.x &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          player.position.x += 0.3;
        }

        if (
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x < block.position.x &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {
          player.position.x -= 0.3;
        }

        if (
          player.position.z - 0.5 < block.position.z + halfWallDepth &&
          player.position.z > block.position.z &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          player.position.z += 0.3;
        }

        if (
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z < block.position.z &&
          player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
          player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth
        ) {
          player.position.z -= 0.3;
        }

        if (
          player.position.y - 0.4 < block.position.y + halfWallHeight &&
          player.position.y > block.position.y &&
          player.position.x + 0.5 > block.position.x - halfWallWidth &&
          player.position.x - 0.5 < block.position.x + halfWallWidth &&
          player.position.z + 0.5 > block.position.z - halfWallDepth &&
          player.position.z - 0.5 < block.position.z + halfWallDepth
        ) {

          playerVelocity.set(0, 0, 0);
          player.position.y += (block.position.y - player.position.y) + 0.8;
          cantjump = 0;
          if (block.name === "stone") {
            steponstone = 1;
          }
          jumping = 1;
          if (player.position.y < jumpposition - 1.5) {
            hurt();
          }
        } else {
          cantjump = 1;
          if (block.name !== "stone") {
            steponstone = 0;
          }
          if (fallingdmgisactive == 1) {
            if (playerVelocity.y < 0) {

            }
          }
        }
      }
    }

    for (const cloud of clouds) {
      cloud.position.x -= 0.1;
      if (cloud.position.x < -150) {
        cloud.position.x = 300;
      }
    }
if (experiments.test1 == 0) {
  renderer.render(scene, camera);
}
  };

  animate();

  function fastrendering() {
    if(experiments.test1==1){
    renderer.render(scene, camera);

    requestAnimationFrame(fastrendering)
    }
  }
  fastrendering()

  lod.addLevel(scene, 1);

  let touchStartX = 0;
  let touchStartY = 0;

  function onTouchStart(event) {
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
  }

  function onTouchMove(event) {
    const touchX = event.touches[0].clientX;
    const touchY = event.touches[0].clientY;

    const deltaX = (touchX - touchStartX) * 0.02;
    const deltaY = (touchY - touchStartY) * 0.02;

    camera.rotation.y -= deltaX;
    camera.rotation.x -= deltaY;

    touchStartX = touchX;
    touchStartY = touchY;
  }

  document.addEventListener('touchstart', onTouchStart);
  document.addEventListener('touchmove', onTouchMove);

  const previewGeometry = new THREE.BoxGeometry(1, 1, 1);

  const blockMaterial2 = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });

  let previewBlock = new THREE.Mesh(previewGeometry, blockMaterial2);

  scene.add(previewBlock);

  function animateOpacity() {
    const opacityValue = previewBlock.material.opacity;
    showIndicationForWallsinOtherBlocks()

    const targetOpacity = opacityValue === 0.6 ? 0.2 : 0.6;

    const duration = 300;
    const startTime = Date.now();

    function updateOpacity() {
      const currentTime = Date.now() - startTime;
      const progress = Math.min(currentTime / duration, 1);
      const newOpacity = opacityValue + (targetOpacity - opacityValue) * progress;

      previewBlock.material.opacity = newOpacity;

      if (progress < 1) {
        requestAnimationFrame(updateOpacity);

      }
    }

    updateOpacity();
  }

  setInterval(animateOpacity, 400);

  let previewBlockAdded = false;

  function showIndicationForWallsinOtherBlocks(event) {
    updateInventory();
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);

    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
    });

    const intersects = raycaster.intersectObjects(blocksInCurrentChunk);

    if (intersects.length > 0) {
      const clickedBlock = intersects[0].object;
      const blockPosition = new THREE.Vector3();
      clickedBlock.getWorldPosition(blockPosition);

      blockPosition.x = Math.floor(blockPosition.x);
      blockPosition.y = Math.floor(blockPosition.y);
      blockPosition.z = Math.floor(blockPosition.z);

      const intersectionPoint = intersects[0].point;
      const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

      let newPosition = blockPosition.clone();

      if (relativePosition.y > 0) {
        newPosition.y += 1;
      } else if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {

        newPosition.x += Math.sign(relativePosition.x);
      } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {

        newPosition.z += Math.sign(relativePosition.z);
      } else {

      }

      previewBlock.position.copy(newPosition);
      previewBlockAdded = true;

    } else {

      if (previewBlockAdded) {

        previewBlock.position.set(Infinity, Infinity, Infinity);
        previewBlockAdded = false;

      }
    }
  }

  function buildBlockOnClick(event) {
    updateInventory()

    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(blocks);

    if (intersects.length > 0) {

      const clickedBlock = intersects[0].object;
      const blockPosition = new THREE.Vector3();
      clickedBlock.getWorldPosition(blockPosition);

      blockPosition.x = Math.floor(blockPosition.x);
      blockPosition.y = Math.floor(blockPosition.y);
      blockPosition.z = Math.floor(blockPosition.z);

      const intersectionPoint = intersects[0].point;
      const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

      if (currentblock == 'stone') {
        currentitemslot = 'stone';
        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, wooden);
          newBlock.name = "stone"
          var searchedItem = "stone";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      } else if (currentblock == 'wood') {
        currentitemslot = 'wood'

        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, stonen);
          newBlock.name = 'wood'
          var searchedItem = "wood";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      } else if (currentblock == 'grass') {
        currentblock = 'grass'
        currentitemslot = 'grass'
        if (cantbuildthisblockGeometry == 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = 'grass'
          var searchedItem = "grass";
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }
          useblock(index)
        }
      }
      else if (currentblock == 'glowstone') {
        currentitemslot = currentblock;

        if (cantbuildthisblockGeometry === 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = currentitemslot;

          var searchedItem = currentitemslot;
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }

          if (index !== -1) {
            if (items[index][3] && window.hasOwnProperty(items[index][3])) {

              var customMaterial = window[items[index][3]];
              newBlock.material = customMaterial;
            } else {

              var itemTexture = new THREE.TextureLoader().load(items[index][2]);
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshBasicMaterial({ map: itemTexture, transparent: true, alpha: true });
              newBlock.material = itemMaterial;
            }
          }

          useblock(index);
        }
      }
      else {

        currentitemslot = currentblock;

        if (cantbuildthisblockGeometry === 0) {
          var newBlock = new THREE.Mesh(blockGeometry, materials);
          newBlock.name = currentitemslot;

          var searchedItem = currentitemslot;
          var index = -1;

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key;
              break;
            }
          }

          if (index !== -1) {
            if (items[index][3] && window.hasOwnProperty(items[index][3])) {

              var customMaterial = window[items[index][3]];
              newBlock.material = customMaterial;
            } else {

              var itemTexture = new THREE.TextureLoader().load(items[index][2]);
              itemTexture.magFilter = THREE.NearestFilter;
              itemTexture.minFilter = THREE.NearestFilter;
              var itemMaterial = new THREE.MeshStandardMaterial({ map: itemTexture, transparent: true, alpha: true });
              newBlock.material = itemMaterial;
            }
          }

          useblock(index);
        }

      }

      let newPosition = blockPosition.clone();

      if (relativePosition.y > 0) {
        newPosition.y += 1;
      }
      else
      if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {

        newPosition.x += Math.sign(relativePosition.x);
      } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {

        newPosition.z += Math.sign(relativePosition.z);
      } else {

        newPosition.y += Math.sign(relativePosition.y);
      }

      var audio = new Audio('./stone4.ogg');

      audio.play();
      newBlock.position.copy(newPosition);

      scene.add(newBlock);
      blocks.push(newBlock);

      addPointLightsToGlowstones()
    }

  }

  let glowstoneLightsMap = new Map();

  function addPointLightsToGlowstones() {
    const playerChunkX = Math.floor(player.position.x / rdist);
    const playerChunkZ = Math.floor(player.position.z / rdist);

    const blocksInCurrentChunk = blocks.filter(block => {
      const blockChunkX = Math.floor(block.position.x / rdist);
      const blockChunkZ = Math.floor(block.position.z / rdist);
      return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
    });

    glowstoneLightsMap.forEach((light, block) => {
      if (!blocksInCurrentChunk.includes(block) || !isGlowstonePresent(block.position)) {
        scene.remove(light);

        if (light) {
          if (light.material) light.material.dispose();
          if (light.geometry) light.geometry.dispose();
        }

        glowstoneLightsMap.delete(block);

        const torchIndex = torches.indexOf(block);
        if (torchIndex !== -1) {
          torches.splice(torchIndex, 1);
        }
      }
    });

    blocksInCurrentChunk.forEach(block => {
      if (block.name === 'glowstone' && isGlowstonePresent(block.position)) {
        const existingLight = glowstoneLightsMap.get(block);

        if (existingLight) {

          existingLight.position.copy(block.position);
        } else {

          const blockLight = new THREE.PointLight(0xffffff, 2, 10);
          blockLight.position.copy(block.position);
          scene.add(blockLight);

          torches.push(block);
          glowstoneLightsMap.set(block, blockLight);
        }
      }
    });
  }

  function isGlowstonePresent(position) {

    return blocks.some(glowstone => glowstone.position.equals(position) && glowstone.name === 'glowstone');
  }

  let torches = [];

  window.setInterval(addPointLightsToGlowstones, 9500);

  function deleteBlockOnClick(event) {
    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(blocks);

    if (intersects.length > 0) {

      const clickedBlock = intersects[0].object;

      if (clickedBlock.name === "stone") {
        addblock("stone");
        recipesadd("Stone age!", "./cobble.png");
      } else if (clickedBlock.name === "chest") {
        if (Math.floor(Math.random() * 3) == 2) {
          for (var i = 0; i < 30; i++) {
            addblock("brick");

          }
        } else if (Math.floor(Math.random() * 2) == 1) {
          for (var i = 0; i < 30; i++) {
            addblock("glass");

          }
        } else if (Math.floor(Math.random() * 3) == 1) {
          for (var i = 0; i < 30; i++) {
            addblock("wood");
          }
        } else if (Math.floor(Math.random() * 3) == 1) {
          for (var i = 0; i < 15; i++) {
            addblock("polishedstone");

          }
        } else {
          for (var i = 0; i < 2; i++) {
            addblock("glowstone");
recipesadd("Rare Loot!", "./chest_front.png");
          }
        }
      } else if (clickedBlock.name === "woodblock") {
        addblock("wood");
        addblock("wood");
        addblock("wood");
        addblock("wood");
        recipesadd("Get Wood!", "./pobrane (16).png");
      } else if (clickedBlock.name === "grass") {
        addblock("grass");
      } else if (clickedBlock.name === "stone") {
        addblock("wood");
      } else {
        addblock(clickedBlock.name)
      }
      if(clickedBlock.name === "brick"){
        recipesadd("Brick Break!", "./pobrane (12).png");
      }
      if (clickedBlock.name === "polishedstone") {
        recipesadd("Polished !", "./pobrane (11).png");
      }
      var audio = new Audio('./stone1.ogg');

      audio.play();

      const index = blocks.indexOf(clickedBlock);
      if (index !== -1) {
        blocks.splice(index, 1);
        scene.remove(clickedBlock);
      }
      addPointLightsToGlowstones()
    }
  }

  let elapsedTime = 0;
const loader = new GLTFLoader();
  function changeBackgroundAndLight() {

    for (var i = 0; i < 2; i++) {

recipesadd("Night Time ", "./chest_front.png");
      scene.fog = new THREE.FogExp2(0x000000, 0.09);






loader.load(
  './model.gltf', 
  (gltf) => {
    let creeper3 = gltf.scene; 

    creeper3.scale.set(0.05, 0.055, 0.05);
    creeper3.position.set(chunkX * rdist + Math.floor(Math.random() * rdist), 5, chunkZ * rdist + Math.floor(Math.random() * rdist));

    scene.add(creeper3);
    creepers.push(creeper3);
  }
);

    }

    const duration = 15000;
    const startTime = Date.now();
    const minLightIntensity = 0.02;

    const gameElement = document.getElementById('game');

    function update() {
      const currentTime = Date.now() - startTime;

      const progressLight = Math.min(currentTime / duration, 1);
      const newLightIntensity = Math.max(minLightIntensity, 0.9 - 0.2 * progressLight * 5);
      light.intensity = newLightIntensity;

      gameElement.classList.add('night')
      scene.remove(ambientLight)
      ambientLight = new THREE.AmbientLight(0x111111)
      scene.add(ambientLight)
      scene.fog = new THREE.FogExp2(0x000000, 0.3);

      if (currentTime < duration) {
        requestAnimationFrame(update);

      } else {
        setTimeout(changeBackgroundAndLight2, 200000);
      }
    }

    update();
  }

  setTimeout(changeBackgroundAndLight, 400000);

  function changeBackgroundAndLight2() {
    const duration = 35000;
    const startTime = Date.now();
    const minLightIntensity = 0.02;

    const gameElement = document.getElementById('game');

    function update() {
      const currentTime = Date.now() - startTime;

      const progressLight = Math.min(currentTime / duration, 1);
      const newLightIntensity = Math.min(0.6, minLightIntensity + 0.2 * progressLight * 2);
      light.intensity = newLightIntensity;

      gameElement.classList.add('day');
recipesadd("Survive first Day", "./glowstone.png");
scene.fog = new THREE.FogExp2(0xffffff, 0.015);
     scene.remove(ambientLight)

      ambientLight = new THREE.AmbientLight(0x707070)
      scene.add(ambientLight)
      scene.fog = new THREE.FogExp2(0xffffff, 0.09);

      if (currentTime < duration) {

        requestAnimationFrame(update);
        gameElement.classList.remove('night');
      } else {
        gameElement.classList.remove('day');
        setTimeout(changeBackgroundAndLight, 300000);
      }
    }

    update();
  }

var  currentblock = 'stone'
var  blockClickEnabled = false

 switchi =  function(data) {
    if (data == "stone") {

      canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'stone'
    } else if (data == "wood") {

      canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'wood'
    } else if (data == "grass") {

      canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = 'grass'
    } else if (data == "pickaxe") {

      canv.removeEventListener('click', buildBlockOnClick);
      canv.addEventListener('click', deleteBlockOnClick);

    } else {

      canv.removeEventListener('click', deleteBlockOnClick);
      canv.addEventListener('click', buildBlockOnClick);

      currentblock = data
    }
  }

  window.addEventListener('resize', function() {
    var newScreenWidth = window.innerWidth;
    var newScreenHeight = window.innerHeight;

    renderer.setSize(newScreenWidth, newScreenHeight);

    camera.aspect = newScreenWidth / newScreenHeight;
    camera.updateProjectionMatrix();
  });

  function fori() {
    camera.getWorldPosition(cameraPosition);
    camera.getWorldDirection(cameraDirection);

    var blockPosition = block.getWorldPosition(new THREE.Vector3());

    var directionToBlock = blockPosition.sub(cameraPosition).normalize();

    var dotProduct = cameraDirection.dot(directionToBlock);
    if (dotProduct > 0.99) {

      block.material.color.set(0xffffff);
     
    } else {

      block.material.color.set(0x00ff00);
      
    }
  }

  function test() {

  }
  window.setInterval(test, 10000)

  var hurtperseconds = 0

  let canHurt = true;
  let lastHurtTime = 0;

  function hurt() {
    jumpposition = player.position.y;
    const currentTime = Date.now();
    const timeSinceLastHurt = currentTime - lastHurtTime;
    document.getElementById('game').classList.add('dead');
    setTimeout(function() {
      document.getElementById('game').classList.remove('dead');
    }, 10000);

    if (timeSinceLastHurt >= 100) {

      const heartsContainer = document.getElementById("hearts");

    const lastHeart = heartsContainer.lastChild;
heartsContainer.removeChild(lastHeart);
      setTimeout(function() {
        if (heartsContainer.children.length > 0) {

          if (heartsContainer.children.length === 0) {

            warn2("You died");

            for (var i = 0; i < 11; i++) {
              heartsContainer.innerHTML += '<div class="heart"></div>';
            }
            player.position.y = 15;
            player.position.x = 15;
            player.position.z = 15;
            playerVelocity.set(0, 0, 0);

          }
        }
      }, 500);

      lastHurtTime = currentTime;
      var audio = new Audio('hurt.ogg');

      audio.play();
    }
  }

  function test2() {

  }
},5000);
}
</script>

<script>
  var audio2 = new Audio('./hal3.ogg');

  function playnaunce1() {
    let random = Math.floor(Math.random() * 2)

    if (audio2.paused) {
      audio2.src = './calm1.ogg';
      if (random == 0) {

        audio2.src = './hal3.ogg';
      }
      if (random == 1) {

        audio2.src = './nuance1.ogg';
        warn2(random)
      } 
      if (random > 1 && random < 3) {
        audio2.src = './calm3.ogg'
      } else
      if (random > 2 && random < 4) {
        audio2.src = './calm1.ogg'
      }
      audio2.play();
    }

  }
  window.setInterval(playnaunce1, 10000)
</script>

    <style>
        #recipeBar {
            position: fixed;
            white-space: pre-wrap;
            top: 10px;
            right: -400px;
            width: 200px;
            height: 30px;
            background-color: #787878;
            color: white;
            text-align: right;

            padding: 10px;
            transition: 2.5s;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #recipeBar img {
            position: absolute;
            left: 5px;
            top: 5px;
            width: 40px;
            height: 40px;
            margin-right: 10px;
            image-rendering:pixelated;
        }
    </style>
</head>
<body>

<pre id="recipeBar" ></pre>

<script>
    let unlockedRecipes = [];

    function isRecipeAdded(recipe) {
        return unlockedRecipes.includes(recipe);
    }

    function recipesadd(recipe, img) {

        if (isRecipeAdded(recipe)) {
            console.log("Receptura juÅ¼ dodana");
            return;
        }else{

        unlockedRecipes.push(recipe);

        const recipeBar = document.getElementById("recipeBar");
        recipeBar.innerHTML = `<img src="${img}" alt="${recipe}">${recipe}            `;

        setTimeout(() => {
            recipeBar.style.right = "-5px";
        }, 200);

        setTimeout(() => {
            recipeBar.style.right = "-400px";
        }, 5000);
        }
    }

</script>

</div>

</html>
