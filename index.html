

<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<html lang="en" onclick="openFullscreen()" >

       <div id="game-menu" class="none" style="position:fixed ;z-index:3; top:0;left:0;height:50vh;width:50vw;background : #CACACA6B ;color:white  ;font-size:24px; top:50vh; left :50vw; transform:translate(-50%,-50%);" >

<pre style="white-space :pre-wrap ">
 Workbench Classic Minecraft
 by: kashumyGithub
 orginal: mojang Minecraft 
</pre>
<script>

  var isloading = 0
  var cloudsis=1



    function openFullscreen() {
        var elem = document.documentElement;

        if (elem.requestFullscreen) {
            elem.requestFullscreen().then(rotateScreen);
        } else if (elem.mozRequestFullScreen) {  // Firefox
            elem.mozRequestFullScreen().then(rotateScreen);
        } else if (elem.webkitRequestFullscreen) {  // Chrome, Safari and Opera
            elem.webkitRequestFullscreen().then(rotateScreen);
        } else if (elem.msRequestFullscreen) {  // IE/Edge
            elem.msRequestFullscreen().then(rotateScreen);
        }
        rotateScreen()
    }

    function rotateScreen() {
        if (screen.orientation) {
            // ObrÃ³Ä‡ ekran w tryb landscape
            screen.orientation.lock("landscape");
        }
    }




</script>

       </div>
         <style>
.alert2{
  position :fixed ;
  right :20px;
  top:20px;
  z-index :2;
  width :200px;
  height :50px;
  background :#4C4C4C61;
  color :#FFFFFF;
}
         </style>
  <script>
function warn2(message) {
  var alertDiv = document.createElement("div");
  alertDiv.className = "alert2";
  alertDiv.innerHTML = message;

  document.body.appendChild(alertDiv);
  alertDiv.classList.add("show");

  setTimeout(function() {
    alertDiv.classList.remove("show");
    setTimeout(function() {
      alertDiv.remove();
    }, 300); 
  }, 2000); 
}

    function menu_game(){
      document.getElementById('game-menu').classList.toggle('none')
    }
  </script>

  <style>
    .none{
      display :none ;
    }
  </style>

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Menu</title>
    <style>
    dvt{
      position :fixed ;
      background-image: url('./03.jpg'); 
            background-size: 100%;
            background-position: center;
            width :100%;
            height :100%;
            image-rendering: pixelated;
    }

@font-face {
  font-family: 'mc';
  src: url('./Minecraft.ttf');
}

        body {
          position :fixed ;
          width :100%;
          height :100vh;
          background :#000000;
            margin: 0;
            padding: 0;

            font-family: "mc";
        }
@media screen and (max-width: 769px) {
dvt{
  background-size :150%;
  top:50vh;
  transform:translate(0%,-50%);
  background-repeat :no-repeat ;

}
}
        .menu-container {
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #42445A00;
            padding: 20px;
            border-radius: 10px;
        }

        .menu-button {
            display: block;
            background :url('./button.png');
            background-size: 100%;
            font-family :'mc';

            background-repeat: no-repeat ;
            width: 350px;
            padding: 10px;
            margin: 10px auto;

            color: white;
            text-decoration: none;

            font-size: 18px;
        }
        *{
          font-family :'mc';
        }

        .menu-button:hover {

        }
        #logo{
          width :100px;
          height :100px;
          position :absolute ;
          top:50%;
          transform:translate(-50%,-50%);
          left:50%;
          background-image :url('./cn.png');

        }
        .opct{
          opacity :0;
          animation :opct 2s linear ;
        }
        @keyframes opct{
          0%{
            opacity :1;
          }
          100%{
            opacity :0;
          }
        }
    </style>
</head>
<style>
#splash{
  animation : buc 2s infinite ;
  rotate: -10deg
}
@keyframes buc{
  0%{

  }
  50%{
    scale :1.2
  }
  100%{
    scale :1.0
  }
}
</style>
<script>
  setTimeout(function() {
  var splashContainer = document.getElementById('splash');

  
  var splashes = [
    "Creeper, aw man!",
    "Creeper, aw man!",
    "Creeper, aw man!",
    "<text style='font-size :40px:'>Big text </text>",
    "<text style='font-size :40px:'>Big text 2 </text>",
    "<text style='font-size :100px:'>Big text 3</text>",

    "keep going !",
    "Redstone dust can power a lot of stuff!",
    "Diamonds are a miner's best friend!",
    "2009",
    "Keep calm",
    "Building a dirt house... survival mode!",
    "Endermen are shy... and creepy!",
    "Classic alpha is good",
    "Don't dig straight down!",
    "Crafting is the key to success!",
    "Hugs for everyone!",
    "Keep mining and stay crafty!",
    "Cows go moo!",
    "Chickens lay eggs!",
    "On mobile only",
    "try terraria",
    "Your sand box world",
    "Building is so much fun!",
    "Take creative ",
    " confusion ",
    "krystian Kashumy ",
    "mojang say no updates for now",
    "Adventure Awaits Beyond the Horizon.",
    "sit on the chair my child ",
    "broadcast message from the studio: Don't be fooled, the crepper is waiting for you",
    "so, so, hmgm. regardless of my will, I must inform you that this is my favorite message ðŸ˜ˆðŸ”¥",
    "menage items in your slots",
    "collect block for buildings !",

    "<pre style='color:red' > This is make old version of minecraft challenge <br> Bugs !",
    " <text style='color :lime'>try to find </text>",
    "<text style='color :blue'> Unknown message </text>",
    "<text style='color :orange '> Easy Lag</text>",
    "yellow pilar",
    "uwu",
    "Big number of splashes ",
  "Adventure awaits!",
  "Mine and build!",
  "Diamonds shine bright!",
  "Crafting and smelting!",
  "Exploring the depths!",
  "Wings of freedom!",
  "Beware of the Enderman!",
  "Build your world!",
  "Survival is key!",
  "Discover new horizons!",
  "Sailing the oceans!",
  "Beware of creepers!",
  "Guardians of the realm!",
  "Treasures in the dark!",
  "Green pastures ahead!",
  "Obsidian fortress!",
  "Lapis Lazuli treasures!",
  "Unlock enchantments!",
  "Mobs in the night!",
  "Bones of the earth!",
  "Clay by the river!",
  "Blooming flowers!",
  "Potatoes and carrots!",
  "Redstone wonders!",
  "Buzzing with bees!",
  "Eggs of potential!",
  "Ender pearl magic!",
  "Sheep herding time!",
  "Moonlit adventures!",
  "Aim true with arrows!",
  "Face the challenge!",
  "Cows in the pasture!"

  ];

  
  for (var i = 0; i < 20; i++) {
    var randomIndex = Math.floor(Math.random() * splashes.length);
    var splashText = splashes[randomIndex];

    
    var splashDiv = document.createElement('div');
    splashDiv.className = 'splash';
    splashDiv.textContent = splashText;

    
    splashContainer.innerHTML=splashDiv.innerText;
  }
}, 3000);

</script>
<body>
  <dvt></dvt>

   <div id="ss" style="position:fixed ;z-index:3; top:0;left:0;height:100vh;width:100vw;background :white ;color:black ;font-size:4px; " >

<img src="./cn.png" id="logo">
   </div>

    <div class="menu-container">
      <div style="position: absolute; top:0; left:0;"> indev 0.5 </div>
        <img src="./Workbench.png" style="width :390px" alt="">
        <img src="./classic.png" style="width :100px" alt="">
        <div id="splash" style="color :yellow; margin-top :-30px; margin-left :250px" >
          Now on mobile
        </div>
        <a class="menu-button" onclick="play()">Play</a>
        <a class="menu-button" href="#">Options</a>
        <a class="menu-button" href="#">Exit Game</a>

    </div>
        <div style="position :fixed ; bottom :0px ; left :0px; color :white ;">
              Consout Copyright Â© You can distribute
            </div>
</body>
</html>
<script>

  if(isloading==1){
setTimeout(function (){
  document.getElementById('ss').classList.add('opct')
  setTimeout(function (){
    document.getElementById('ss').style.display ="none"
  },2000)
},6000)
  } else {
setTimeout(function() {
      document.getElementById('ss').classList.add('opct')
      setTimeout(function() {
        document.getElementById('ss').style.display = "none"
      }, 2000)

}, 100)
  }
var lbar=document.getElementById('lbar')
var progress=0
function playworld(data){

  lbar=document.getElementById('lbar')
  document.querySelector('.menu').style.display ="none"
  document.getElementById('lading').style.display ="block"
 var max = 100;

for (var i = 0; i <= max; i++) {
  (function(i) {
    setTimeout(function() {
      progress+=1
      lbar.style.width = progress + "%"
    }, i * 100); 
  })(i);
}

if(isloading==1){
  setTimeout(function (){
  if(data=="world1"){
    document.getElementById('game-container').style.display ="block"

  }
  },13000)
} else {
  if (data == "world1") {
    document.getElementById('game-container').style.display = "block"
  }
}

}
if(isloading==1){
setTimeout(function (){
  document.getElementById('game-container').style.display ="none"
},4000)
}
function play(){
  document.querySelector('.mmenu').style.display ="block"
}
function canel() {
  document.querySelector('.mmenu').style.display = "none"
}
</script>
<div class="mmenu">

<div id="lading" style="width :100%;height :100vh; display :none; position :absolute ">

       <pre style="color :white ; text-align :center ;position :absolute; transform:translate(-50%,-50%); top:calc(50vh - 60px); left :50vw;">Building terrain</pre>
     <div id="" style="width :200px;height :10px; position :absolute; transform:translate(-50%,-50%); top:50vh; left :50vw; background-color :gray " >

       <div id="lbar" style="width :0%; background :lime ; height :100%; filter :brightness(1.0)">

       </div>
     </div>

</div>
  <div class="menu">

  <div onclick="playworld('world1')" >world1</div>
      <div class="bt" id="bt" style="width :200px" onclick="canel()" >canel</div>
  <div>--empty--</div>
  <div>--empty--</div>
  <div>--empty--</div>
  <div>--empty--</div>

</div>
</div>

<style>
#game-container{

}
.dead{
  animation : 0.15s dmg  steps(1) , 0.3s rtt  ;

}
@keyframes dmg{
  0%{
    filter :hue-rotate(-100deg);
    scale: 2.6
  }
}
@keyframes rtt {
  0% {
scale :2.0
  }
  50%{
    rotate: -5deg 
  }
  100%{
    rotate : 5deg
    scale :1.5
  }
}
.menu{
  position :fixed ;
  overflow :hidden ;
  overflow :scroll ;
  top:50vh;
  left:50vw;
  background :#0F0F0F80;
  transform:translate(-50%,-50%);
  width :80%;
  padding :10px;
  height :calc(50vh + 100px);
}
.menu div{
  width :calc(100% - 10px);
  background :url('./button.png');
  background-size: 100%;
  background-repeat: no-repeat ;
 padding: 5px;
 margin-bottom: 5px;
 color :white ;
 font-weight: bold ;
 text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
 font-family :'mc';
  height :30px;

}
#bt{
  position :fixed ;
  left : 20px;
  bottom: 0px
}
.bt{
  width :40px;
  background :#747474;
  padding :10px;
  background-size: 100%;
  background-repeat: no-repeat;
  padding: 5px;
  margin-bottom: 5px;
  color :#FFFFFF;
  font-weight: bold;
  text-shadow: 0px 2px 0px rgba(0, 0, 0, 0.4);
  font-family :'mc';
  font-size :13px;
  background-repeat: no-repeat ;

}
  .mmenu{
    position :fixed ;
    display :none ;
    width :100%;
    height :100%;
    background :url('./pobrane (8).png');
    background-size: 40px;
    image-rendering :pixelated ;
    filter :brightness(0.5);
  }
</style>

    <style>
    html{
      position :fixed ;
      width :100%;
      height :100vh;
      user-select :none ;
      user-zoom: none ;
      min-zoom: 1;
      max-zoom: 1;
      margin :0;
      padding :0;
    }
.item-slot {
  width: 50px;
  height: 50px;
  background: url('./itemslot.png');
  float: left;
  background-size: 100%;
  image-rendering: pixelated;
  margin-left: 3px;
  transition: background-color 0.3s ease; 
}

.item-slot:hover {
  background: #f0f0f0; 
}

    #items{
      width :370px;
      height :100px;
      position :absolute ;
      bottom :-10px;
      overflow: hidden;
      overflow: scroll;
      left:55vw;
      background :#1E1E1E2E;
      transform:translate(-50%,0%);
      z-index :1;
    }
        body { }
        #game { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; background: #87CEEB; }
        #controls { position: fixed; bottom: 20px; left: 20px; z-index :2; width :200px; overflow :hidden; zoom:0.8 }
        .null{
          user-select :none;
          width :50px;
          margin :5px;
          height :50px;
          background :#42445A00;
          color :#FFFFFF;
          float :left ;
        }
        button { margin: 5px; }
        .btn{
          border :0px solid #626262;
          user-select :none ;
          width :50px;
          background :url('./btn.png');
          float :left ;
          height :50px;
        
          color :#FFFFFF;
        }
        #debug{
          width: 90px;
          height: 5px;
          padding: 10px;
          background: #FCFCFC6E;
          position:fixed;
          z-index:9;
          bottom:0;
          left:0;
        }
    </style>
</head>
<div id="debug">
x:<t id="xpos"></t>y:<t id="ypos"></t>z:<t id="zpos"></t>
</div>
<div id="game-container">

    <div id="fps-counter" style="position: fixed ; top: 10px; right: 10px; background-color: rgba(0, 0, 0, 0.5); color: white; padding: 5px; z-index :999"></div>
  <div id="items">
    <div id="hearts">
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>
<div class="heart"></div>

    </div><style>
      #hearts{
        width :100%;
        height :20px;

      }
      .heart{
        background-image :url('./heart.png');
        width :20px;
        margin-left :-5px;
        height :20px;
        float :left ;
        image-rendering :pixelated ;
        background-size: 100%;
      }

.night {
  background-color: #000000;
  animation: nights 35s forwards steps(30);
}

.day {
  background-color: #53D8F0;
  animation: days 35s forwards steps(30);
}

@keyframes nights {
  0.1% {
    background: #87CEEB;
  }
  30% {
    background: linear-gradient(#3988A2,#EBAF1A);
  }
  50% {
    background: #0E4E69;
  }
  80% {
    background: #07244F;
  }
  100% {
    background: #000000;
  }
}

@keyframes days {
  0.1% {
    background: #000000;
  }
  20% {
    background: #07244F;
  }
  50% {
    background: #0E4E69;
  }
  70% {
    background: #3983A2;
  }
  99.9% {
    background: #87CEEB;
  }
  100% {
    background: #000000;
  }
}

    </style>
    <div class="item-slot" onclick="switchi('pickaxe')"><img style="width:60%;height :60%;margin :20%" src="./pickaxe.png" alt=""></div>
  </div>
   <script>
     var cantbuildthisblockGeometry = 0;
   var items = {
     "1": ["stone", 0, "./pobrane (14).png"],
     "2": ["grass", 0, "./pobrane (9).png"],
     "3": ["wood", 0, "./pobrane (10).png"],
     "4": ["water", 0, "./water.png","water2"],
     "5": ["leaves", 0, "./pobrane (19).png"],
     "6": ["brick", 0 , "./pobrane (12).png"]
   };
   var nocollisions=["water"]
   
   function createItemSlots() {
     const itemSlotsContainer = document.getElementById('items');

     
     const maxSlots = Math.min(6, Object.keys(items).length);

     for (let i = 1; i <= maxSlots; i++) {
       const itemInfo = items[i.toString()];
       const [itemName, itemCount, itemImage] = itemInfo;

       const itemSlot = document.createElement('div');
       itemSlot.className = 'item-slot';
       itemSlot.style.position = 'relative';
       itemSlot.id=`itemslot${i}`
       itemSlot.innerHTML = `
           <img style="width:60%;height:60%;margin:20%" src="${itemImage}"  alt="">
           <p id="items-slot-${i}" style="position:absolute;top:0%;z-index:99;left:0%;color:white">x${itemCount}</p>
         `;
       itemSlot.addEventListener('click', function() {
         switchi(itemName);
       });

       itemSlotsContainer.appendChild(itemSlot);
     }
   }

   
   window.addEventListener('load', createItemSlots);
function checkItemSlotsForItems() {
  const itemSlotsContainer = document.getElementById('items');

  setInterval(() => {
    for (let i = 1; i <= Object.keys(items).length; i++) {
      const itemInfo = items[i.toString()];
      const [itemName, itemCount] = itemInfo;
      const itemSlot = document.getElementById(`itemslot${i}`);

      if (itemCount < 1) {
        
        itemSlot.style.display = 'none';
      } else {
        
        itemSlot.style.display = 'block';
        
      }
    }
  }, 1000); 
}


window.addEventListener('load', checkItemSlotsForItems);

  var currentitemslot='';

   function updateInventory() {
    for (var key in items) {
        if (items.hasOwnProperty(key)) {
            var item = items[key];
            var itemName = item[0];
            var itemCount = item[1];
            var slotId = "items-slot-" + key;
            var slotElement = document.getElementById(slotId);
            if (slotElement) {
                slotElement.textContent = "x" + itemCount; 
            }

        }
    }
    checkItm(currentitemslot)
}

function addblock(typ3){
  var searchedItem = typ3;
  var index = -1; 

  for (var key in items) {
    if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
      index = key; 
      break; 
    }
  }
  items[index][1] += 1
  updateInventory()
}
function useblock(typ3){

  items[typ3][1] -= 1

  updateInventory()

}
function checkItm(typ3){
  var searchedItem = currentitemslot;
  var index = -1; 

  for (var key in items) {
    if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
      index = key; 
if (items[index][1] < 1) {
cantbuildthisblockGeometry = 1
} else {
cantbuildthisblockGeometry = 0
}
      break; 
    }
  }


}
updateInventory()

 </script> 

<img src="./croschair.png" style="position :fixed ; transform:translate(-50%,-50%); top:50vh ;left :50vw; z-index :1">

<div id="game2" style="position:absolute;background: black; width:100%; height:100vh;">
</div>
    <canvas   id="game"></canvas>
    <div id="controls">
      <div class="null"></div>
        <button id="moveForward" class="btn"></button>
        <div class="null"></div>
                <button id="moveLeft" class="btn" ></button>
                      <div class="null"></div>

        <button id="moveRight" class="btn" ></button>
              <div class="null"></div>
        <button id="moveBackward" class="btn"></button>

      

    </div>
            <button id="jump" style="position :fixed ; z-index: 2; right :50px; bottom: 20px" class="btn" ></button>
                  <button id="empty" onclick="menu_game()" style="position :fixed ; right :0px; top: 50px ; font-weight :bold " class="btn" >|&nbsp;&nbsp;|</button>

</div>
    <script src="./three.js"></script>
    <script>


var fpsCounter = document.getElementById('fps-counter');


var frameCount = 0;
var lastTime;
var fps;


function updateFPS() {
  var currentTime = performance.now();
  frameCount++;

  if (!lastTime) {
    lastTime = currentTime;
    return;
  }

  var elapsedMilliseconds = currentTime - lastTime;

  if (elapsedMilliseconds >= 1000) {
    fps = Math.round((frameCount * 1000) / elapsedMilliseconds);
    fpsCounter.innerHTML = 'FPS: ' + fps;
    frameCount = 0;
    lastTime = currentTime;
  }
}

let defaultFps=30
let targetFPS = 30; 
let frameTime = 1000 / targetFPS; 

        
        const scene = new THREE.Scene();
        var canv = document.getElementById("game");
        var width = canv.clientWidth;
        var height = canv.clientHeight;

        
        var camera = new THREE.PerspectiveCamera(90, width / height, 0.01, 300);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("game"), alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        
        const ambientLight = new THREE.AmbientLight(0x555555)
        scene.add(ambientLight)

        const light = new THREE.DirectionalLight(0xffffff, 0.6);
        light.position.set(0, 2, 0);
      
        scene.add(light);


scene.fog = new THREE.FogExp2(0xffffff, 0.09);

light.shadow.mapSize.width = 524;
light.shadow.mapSize.height = 524;
light.shadow.camera.near = 0.1;
light.shadow.camera.far = 200;
        
        const playerGeometry = new THREE.BoxGeometry(0.1,  1, 0.1);
        const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x00000000, transparent :true , opacity :0.0});
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        scene.add(player);

const textureLoader = new THREE.TextureLoader();
const texture = textureLoader.load('./pobrane (12).png');

        
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);

var textureTop = new THREE.TextureLoader().load('./grass.png');
textureTop.magFilter = THREE.NearestFilter; 
textureTop.minFilter = THREE.NearestFilter; 
var textureBottom = new THREE.TextureLoader().load('./pobrane (8).png');
textureBottom.magFilter = THREE.NearestFilter; 
textureBottom.minFilter = THREE.NearestFilter; 
var textureSides = new THREE.TextureLoader().load('./front2.png');
textureSides.magFilter = THREE.NearestFilter; 
textureSides.minFilter = THREE.NearestFilter; 
var water = new THREE.TextureLoader().load('./water.png');

var textureSides2 = new THREE.TextureLoader().load('./pobrane (13).png');
textureSides2.magFilter = THREE.NearestFilter; 
textureSides2.minFilter = THREE.NearestFilter; 
var wood = new THREE.TextureLoader().load('./cobble.png');
var stone1 = new THREE.TextureLoader().load('./pobrane (7).png');
var stone3 = new THREE.TextureLoader().load('./pobrane (10).png');
var wood1 = new THREE.TextureLoader().load('./pobrane (16).png');
var leaves = new THREE.TextureLoader().load('./pobrane (19).png');
leaves.magFilter = THREE.NearestFilter; 
leaves.minFilter = THREE.NearestFilter; 
wood1.magFilter = THREE.NearestFilter; 
wood1.minFilter = THREE.NearestFilter; 
stone1.magFilter = THREE.NearestFilter; 
stone1.minFilter = THREE.NearestFilter; 
stone3.magFilter = THREE.NearestFilter; 
stone3.minFilter = THREE.NearestFilter; 

var water2 = new THREE.MeshStandardMaterial ({ map: water, flatShading: true, transparent: true, opacity: 0.9});
var stone = new THREE.MeshStandardMaterial({ map: stone1, });

var wooden = new THREE.MeshStandardMaterial ({ map: wood,flatShading: true , });
var stonen = new THREE.MeshStandardMaterial ({ map: stone3,flatShading: true , });
var material2 = new THREE.MeshStandardMaterial ({ map: textureSides2 ,flatShading: true , });
var materialTop = new THREE.MeshStandardMaterial ({ map: textureTop,flatShading: true ,transparent: true, opacity: 1 });
var materialBottom = new THREE.MeshStandardMaterial ({ map: textureBottom,flatShading: true , });
var materialSides = new THREE.MeshStandardMaterial ({ map: textureSides,flatShading: true , });

        const blockMaterial = new THREE.MeshLambertMaterial ({ map: texture });

var materials = [
  materialSides, 
  materialSides, 
  materialTop, 
  materialBottom, 
  materialSides, 
  materialSides ,

];
materials[2].shininess = 0;
materials[2].reflectivity = 0;

var blocks = [];
var renderingdist=6


var chunks = [];
var rdist = 25

function checkAndRemoveDuplicateBlocks(currentChunkX, currentChunkZ) {
  const radius = rdist; 

  const blocksToRemove = [];

  for (let i = 0; i < blocks.length; i++) {
    const blockA = blocks[i];

    
    const distance = camera.position.distanceTo(blockA.position);

    if (distance <= radius) {
      const blockChunkX = Math.floor(blockA.position.x / rdist);
      const blockChunkZ = Math.floor(blockA.position.z / rdist);

      
      if (blockChunkX === currentChunkX && blockChunkZ === currentChunkZ) {
        for (let j = i + 1; j < blocks.length; j++) {
          const blockB = blocks[j];

          
          if (
            blockA.position.x === blockB.position.x &&
            blockA.position.y === blockB.position.y &&
            blockA.position.z === blockB.position.z
          ) {
            blocksToRemove.push(blockB);
          }
        }
      }
    }
  }

  
  blocksToRemove.forEach((block) => {
    scene.remove(block);
    const index = blocks.indexOf(block);
    if (index !== -1) {
      blocks.splice(index, 1);
    }
  });

  targetFPS = defaultFps; 
  frameTime = 1000 / targetFPS; 
}

function removeBlocksNearCamera() {
  const radius = 40;

  const blocksToRemove = blocks.filter((block) => {
    const distance = camera.position.distanceTo(block.position);
    return distance <= radius;
  });

  blocksToRemove.forEach((block) => {
    scene.remove(block);
    const index = blocks.indexOf(block);
    if (index !== -1) {
     
    }
  });
}

function generateChunk(x, z) {

 targetFPS = 10; 
 frameTime = 1000 / targetFPS; 
removeBlocksNearCamera()

  renderingdist=7
    const chunk = new THREE.Group();

    

    const layerHeight = -3; 
const voxelSize = 1;
const gridSize = 20;
var numCircles = 3; 
const fillRadius = 0; 

        const voxelsize2= 1;
        const gridsize2= 20;
        const fillRadius2= 0; 

        const voxelCoordinates = [
            [0, 0, 0],
            [1, 0, 0],
    
            [2, 0, 1],
            [2, 0, 2],
            [1, 0, 2],
            [0, 0, 2],
            [2, 0, 0],
            [0, 0, 1],
            [0, 1, 0],
            [1, 1, 0],
          
            [2, 1, 1],
            [2, 1, 2],
            [1, 1, 2],
            [0, 1, 2],
            [2, 1, 0],
            [0, 1, 1],
            [1, 2, 0],
            [1, 2, 1],
            [2, 2, 1],
            [1, 2, 2],
            [0, 2, 1],
[1,1,1,1],
[1,0,1,1],
[1,-1,1,1],
[1,-2,1,1]

        ];

        let randomz = Math.floor(Math.random() * 20) + 5
        let randomx = Math.floor(Math.random() * 20) + 5
var trees=0;
const numberOfTrees = 5; 

for (let i = 0; i < numberOfTrees; i++) {
  const randomx = Math.floor(Math.random() * 20) + 5;
  const randomz = Math.floor(Math.random() * 20) + 5;

  voxelCoordinates.forEach(coords => {
    const [x2, y2, z2, type] = coords;
    let material = new THREE.MeshStandardMaterial({ map: leaves, flatShading: true, transparent: true, opacity: 1.0 });
    if (type === 1) {
      material = new THREE.MeshStandardMaterial({ map: wood1, flatShading: true, transparent: true, opacity: 1.0 });
    }

    const block = new THREE.Mesh(new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize), material);
    block.position.set(x2 + randomx + x * rdist, y2, z2 + randomz + z * rdist);  
    block.name='leaves'
    if(type == 1){
      block.name='woodblock'
    }

    blocks.push(block);

  });
}

let numOfterains1=Math.floor(Math.random()*5)

    for(let j2=0; j2<6; j2++){
      let randomXZ=Math.floor(Math.random()*rdist)
      let randomZX=Math.floor(Math.random()*rdist)
    numCircles =Math.floor(Math.random()*3)+4
    for (var m = -2; m < Math.floor(2); m++) {
      numCircles -= 1
      const dwn = m
      for (let i = 0; i < numCircles; i++) {
        const radius = (Math.random() * 0.5) + i; 
        const segments = 64; 

        for (let j = 0; j < segments; j++) {
          const angle = (j / segments) * Math.PI * 2;
          const xv = (Math.cos(angle) * radius) + (x * rdist);
          const zv = (Math.sin(angle) * radius) + (z * rdist);
          const yv = -2; 

          const distanceToCenter = Math.sqrt(xv * xv + zv * zv);

          if (distanceToCenter > fillRadius) {
            const block = new THREE.Mesh(blockGeometry, materials);
            block.position.set(Math.floor(xv)+randomXZ, dwn, Math.floor(zv)+randomZX);

            block.name = 'grass'
            blocks.push(block)

          }
        }
      }
    }
    }

for (let x2 = 0; x2 < rdist; x2++) { 
    for (let z2 = 0; z2 < rdist; z2++) { 

    if(Math.floor(Math.random()*30)==1){
        const block = new THREE.Mesh(blockGeometry, materials );
        block.name='grass'
        block.position.set(x2 + x *rdist, layerHeight, z2 + z*rdist ); 
      
       

        blocks.push(block);

    }else {
      if(Math.floor(Math.random()*20)==3){
      const block = new THREE.Mesh(blockGeometry, water2 );
     
     
      block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist); 
      
      

      block.name='water'

      blocks.push(block);

    }else{
      const block = new THREE.Mesh(blockGeometry, materials);
      
      
      block.position.set(x2 + x * rdist, layerHeight, z2 + z * rdist); 
      
      

      block.name = 'grass'
      blocks.push(block);

    }}
    }

}

for (let x2 = 0; x2 < rdist; x2++) { 
 for (let y2 = 0; y2 < 2; y2++  )
  for (let z2 = 0; z2 < rdist; z2++) { 

if(Math.floor(Math.random()*15)==3){
var block = new THREE.Mesh(blockGeometry, materials);
var itemTexture = new THREE.TextureLoader().load('./pobrane (12).png');
itemTexture.magFilter = THREE.NearestFilter; 
itemTexture.minFilter = THREE.NearestFilter; 
var itemMaterial = new THREE.MeshBasicMaterial({ map: itemTexture });
block.material = itemMaterial;
block.name = "brick"

}else{
  var block = new THREE.Mesh(blockGeometry, stone);
  block.name = 'stone'
}

    block.position.set(x2 + x * rdist, -4
    -y2, z2 + z * rdist); 
   
  

    blocks.push(block);

  }
}





chunks.push({ x, z, chunk });
generateChunkinprocess_Cave(x,z)

setTimeout(function(){
  checkAndRemoveDuplicateBlocks(x,z)
  renderingdist=6
},4000)
}

const frustum = new THREE.Frustum();


function updateFrustum() {
  camera.updateMatrixWorld();
  camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
  frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
}


function isObjectVisible(object) {
  return frustum.intersectsObject(object);
}
let renderDistance=3
function isBlockVisible(block) {
  const distance = camera.position.distanceTo(block.position);
  return distance < renderDistance; 
}
const blocksInCave = [];

var gins=0
function generateChunkinprocess_Cave(x, z) {

  const chunk = new THREE.Group();

  
  const startHeight = -6;
  
  const endHeight = -22;

  let layerHeight = startHeight; 
  let x2 = 0; 
  let z2 = 0; 
var steponstone=0
  function generateLayer() {

   for(let y = 0; y < 2 ; y++){
    for (let i = 0; i < rdist ; i++) { 
      
      if (layerHeight > endHeight) {
        const block = new THREE.Mesh(blockGeometry, stone);
        block.position.set(x2 + x * rdist, layerHeight-y, z2 + z * rdist);
        
        block.name="stone"
       

        blocks.push(block);
blocksInCave.push(block);

        x2++;
        if (x2 >= rdist) {
          x2 = 0;
          z2++;
          if (z2 >= rdist) {
            z2 = 0;
            layerHeight--; 
          }
        }
      } 
      }

    }

      if (layerHeight > -10) {
        requestAnimationFrame(generateLayer);
      
      }
    

  }

  
  generateLayer();

  


  
  chunks.push({ x, z, chunk });
}


function updateOcclusionCulling() {

}

function updateBlockfaceCulling() {

}

var visibleblocks=[]

function scheduleRandomExecution() {
  const minInterval = 5000; 
  const maxInterval = 60000; 

  const randomInterval = Math.random() * (maxInterval - minInterval) + minInterval;

}


scheduleRandomExecution();

const occlusionRadius = 2; 
const cameraFrustum = new THREE.Frustum();
const cameraViewProjectionMatrix = new THREE.Matrix4();


camera.updateMatrixWorld();
const matrixInv = new THREE.Matrix4().copy(camera.matrixWorld).invert();
cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, matrixInv);

cameraFrustum.setFromProjectionMatrix(cameraViewProjectionMatrix);

function updaterenderdistance(playerChunkX, playerChunkZ) {
  const occlusionRadius = renderingdist+3;
  const additionalDistance = rdist / 2;

  
  const blocksInCurrentChunk = blocks.filter(block => {
    const blockChunkX = Math.floor(block.position.x / rdist);
    const blockChunkZ = Math.floor(block.position.z / rdist);
    return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
  });

  
  blocksInCurrentChunk.forEach(block => {
    const distance = camera.position.distanceTo(block.position);

    if (distance <= occlusionRadius + additionalDistance) {
      if (distance <= occlusionRadius) {
        
        if (!scene.children.includes(block)) {
          scene.add(block);
        }
      } else {
        
        if (scene.children.includes(block)) {
          scene.remove(block);
        }
      }
    } else {

    }
  });
}

let one=0
function updatePlayerChunk() {
  const playerChunkX = Math.floor(player.position.x / rdist);
  const playerChunkZ = Math.floor(player.position.z / rdist);

  // SprawdÅº, czy gracz wchodzi do nowego chunka
  if (!chunks.some(chunk => chunk.x === playerChunkX && chunk.z === playerChunkZ)) {
    // UsuÅ„ chunky, ktÃ³re sÄ… za daleko od gracza
    for (let i = chunks.length - 1; i >= 0; i--) {
      const chunk = chunks[i];
      if (Math.abs(chunk.x - playerChunkX) > 1 || Math.abs(chunk.z - playerChunkZ) > 1) {
       // removeChunk(chunk.x, chunk.z);
       // blocks = []
      }
    }
    // Wygeneruj nowy chunk wokÃ³Å‚ gracza
    generateChunk(playerChunkX, playerChunkZ);
    player.position.y = 4
    if (one == 0) {
      //visibleblocks=(blocks)
      one = 1
     // checkAndRemoveDuplicateBlocks()
      setTimeout(function() {
        one = 0
      }, 1000)
    }
  }
}
        
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
     
        
        const clouds = [];
        if(cloudsis==1){
        for (let i = 0; i < 200; i++) {
            const cloudGeometry = new THREE.BoxGeometry(Math.random()*10+15, 0, Math.random()*10+10);
            const cloudMaterial = new THREE.MeshBasicMaterial ({ color: 0xffffff, transparent: true, opacity: 0.9 });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(Math.random() * 400 - 150, 15, Math.random() * 500 - 150);
            clouds.push(cloud);
            scene.add(cloud);
        }
        }
        
        camera.position.z = -15;
        camera.position.y = 1;
        camera.rotation.order = 'YXZ';
        
        const gravity = new THREE.Vector3(0, -0.045, 0);
        const playerVelocity = new THREE.Vector3();
setTimeout(function (){

  player.position.y = 20
  player.position.x = 12
  player.position.z = 12
  playerVelocity.set(0, 0, 0);
setTimeout(function() {

  player.position.y = 20
  player.position.x = 12
  player.position.z = 12
  playerVelocity.set(0, 0, 0);

}, 1000)
},2100)
        
        const playerSpeed = 0.3;

        
        const moveForwardButton = document.getElementById('moveForward');
        const moveBackwardButton = document.getElementById('moveBackward');
        const moveLeftButton = document.getElementById('moveLeft');
        const moveRightButton = document.getElementById('moveRight');
        const jumpButton = document.getElementById('jump');

        
        let forwardPressed = false;
        let backwardPressed = false;
        let leftPressed = false;
        let rightPressed = false;
        let jumpPressed = false;

        
        moveForwardButton.addEventListener('touchstart', () => {
            forwardPressed = true;
        });
        moveForwardButton.addEventListener('touchend', () => {
            forwardPressed = false;
        });

        moveBackwardButton.addEventListener('touchstart', () => {
            backwardPressed = true;
        });
        moveBackwardButton.addEventListener('touchend', () => {
            backwardPressed = false;
        });

        moveLeftButton.addEventListener('touchstart', () => {
            leftPressed = true;
        });
        moveLeftButton.addEventListener('touchend', () => {
            leftPressed = false;
        });

        moveRightButton.addEventListener('touchstart', () => {
            rightPressed = true;
        });
        moveRightButton.addEventListener('touchend', () => {
            rightPressed = false;
        });
var cantjump=0
var jumping=1
        jumpButton.addEventListener('touchstart', (event) => {
          event.preventDefault()
            if (cantjump==0) { 
            jumpposition=player.position.y
                jumpPressed = true;
            }else if(jumping>0){
              jumpposition = player.position.y
              jumpPressed = true;
              jumping=-1
            }
        });
        jumpButton.addEventListener('click', (event) => {
          event.preventDefault()
          if (cantjump == 0) { 
            jumpposition = player.position.y
            jumpPressed = true;
          } else if (jumping > 0) {
            jumpposition = player.position.y
            jumpPressed = true;
            jumping = -1
          }

        });

        
        const stopMovement = () => {
            playerVelocity.set(0, 0, 0);

        };
var Movementspeed=0.24;
        

var jumpposition=0
var fallingdmgisactive = 0;
setTimeout(function() {
  fallingdmgisactive = 1
}, 6000)
let forwalking=0
let D20times=0
let D5times

        const animate = () => {
          const playerChunkX = Math.floor(player.position.x / rdist);
          const playerChunkZ = Math.floor(player.position.z / rdist);
          if(D5times<1){
            D5times++
          }else{

            updaterenderdistance(playerChunkX,playerChunkZ)
            D5times
          }
          if(D20times<10){

          D20times++
          }else{
            D20times=0
            updatePlayerChunk()
          }

          if(player.position.y < -400){
            hurt()
          }
          document.getElementById("xpos").innerHTML=Math.floor(camera.position.x)
          document.getElementById("ypos").innerHTML=Math.floor(camera.position.y)
          document.getElementById("zpos").innerHTML=Math.floor(camera.position.z)
          updateFPS();
            setTimeout(() => {
              requestAnimationFrame(animate);
            }, frameTime);

camera.position.set(player.position.x, player.position.y+1, player.position.z);
camera.rotation.order = 'YXZ';

            
            playerVelocity.add(gravity);

            

const playerVelocity2 = new THREE.Vector3(0, 0, 0);

if (forwardPressed) {
    
    
const speed = Movementspeed;
if(forwalking<5){
forwalking++
}else{
var audio = new Audio('./grass1.ogg');
forwalking=0

audio.play();
}

const direction = new THREE.Vector3(0, 0, -1.5);
direction.applyQuaternion(camera.quaternion).normalize(); 


const playerVelocity2 = new THREE.Vector3(direction.x * speed, 0, direction.z * speed);


player.position.add(playerVelocity2);

}

else if (backwardPressed) {
                camera.translateZ(Movementspeed);
                player.position.z = camera.position.z
                player.position.x = camera.position.x
            } else {
                playerVelocity.z = 0;
            }

            if (leftPressed) {
                camera.translateX(Movementspeed*-1 );
                player.position.z = camera.position.z
                player.position.x = camera.position.x
            } else if (rightPressed) {
                camera.translateX(Movementspeed);
                player.position.z = camera.position.z
                player.position.x = camera.position.x
            } else {
                playerVelocity.x = 0;
            }

            if (jumpPressed) {
                playerVelocity.y = 0.30;
                jumpPressed = false; 
            }

            player.position.add(playerVelocity);

  const halfPlayerWidth = 0.5;
  const halfPlayerHeight = 0.4;
  const halfPlayerDepth = 0.5;

  const blocksInCurrentChunk = blocks.filter(block => {
    const blockChunkX = Math.floor(block.position.x / rdist);
    const blockChunkZ = Math.floor(block.position.z / rdist);
    return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
  });

  for (const block of blocksInCurrentChunk) {
    const box1 = new THREE.Box3().setFromObject(player);
    const box2 = new THREE.Box3().setFromObject(block);

    
    if (box1.intersectsBox(box2)) {
   
    }
if (!nocollisions.includes(block.name)) {

    
    const halfWallHeight = block.geometry.parameters.height / 2.0;
    const halfWallDepth = block.geometry.parameters.depth / 2.8;
    const halfWallWidth = block.geometry.parameters.width / 2.8;

    if (
      player.position.x - 0.5 < block.position.x + halfWallWidth &&
      player.position.x > block.position.x &&
      player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
      player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
      player.position.z + 0.5 > block.position.z - halfWallDepth &&
      player.position.z - 0.5 < block.position.z + halfWallDepth
    ) {
      player.position.x += 0.3;
    }

    if (
      player.position.x + 0.5 > block.position.x - halfWallWidth &&
      player.position.x < block.position.x &&
      player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
      player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
      player.position.z + 0.5 > block.position.z - halfWallDepth &&
      player.position.z - 0.5 < block.position.z + halfWallDepth
    ) {
      player.position.x -= 0.3;
    }

    if (
      player.position.z - 0.5 < block.position.z + halfWallDepth &&
      player.position.z > block.position.z &&
      player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
      player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
      player.position.x + 0.5 > block.position.x - halfWallWidth &&
      player.position.x - 0.5 < block.position.x + halfWallWidth
    ) {
      player.position.z += 0.3;
    }

    if (
      player.position.z + 0.5 > block.position.z - halfWallDepth &&
      player.position.z < block.position.z &&
      player.position.y + 0.4 > block.position.y - halfWallHeight - 0.3 &&
      player.position.y - 0.4 < block.position.y + halfWallHeight - 0.3 &&
      player.position.x + 0.5 > block.position.x - halfWallWidth &&
      player.position.x - 0.5 < block.position.x + halfWallWidth
    ) {
      player.position.z -= 0.3;
    }

    if (
  player.position.y - 0.4 < block.position.y + halfWallHeight &&
  player.position.y > block.position.y &&
  player.position.x + 0.5 > block.position.x - halfWallWidth &&
  player.position.x - 0.5 < block.position.x + halfWallWidth &&
  player.position.z + 0.5 > block.position.z - halfWallDepth &&
  player.position.z - 0.5 < block.position.z + halfWallDepth
) {
  
  playerVelocity.set(0, 0, 0);
  player.position.y += (block.position.y - player.position.y) + 0.8;
  cantjump = 0;
  if (block.name === "stone") {
    steponstone = 1;
  }
  jumping = 1;
  if (player.position.y < jumpposition - 1.5) {
    hurt();
  }
} else {
  cantjump = 1;
  if (block.name !== "stone") {
    steponstone = 0;
  }
  if (fallingdmgisactive == 1) {
    if (playerVelocity.y < 0) {
      
    }
  }
}}
}

            
            for (const cloud of clouds) {
                cloud.position.x -= 0.1; 
                if (cloud.position.x < -150) {
                    cloud.position.x = 300;
                }
            }

        };

        animate();
function fastrendering(){
renderer.render(scene, camera);
requestAnimationFrame(fastrendering)
}
fastrendering()
       

        


let touchStartX = 0;
let touchStartY = 0;

function onTouchStart(event) {
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
}

function onTouchMove(event) {
    const touchX = event.touches[0].clientX;
    const touchY = event.touches[0].clientY;

    const deltaX = (touchX - touchStartX) * 0.02;
    const deltaY = (touchY - touchStartY) * 0.02;

    camera.rotation.y -= deltaX;
    camera.rotation.x -= deltaY;

    touchStartX = touchX;
    touchStartY = touchY;
}


document.addEventListener('touchstart', onTouchStart);
document.addEventListener('touchmove', onTouchMove);









const previewGeometry = new THREE.BoxGeometry(1, 1, 1);


const blockMaterial2 = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });


let previewBlock = new THREE.Mesh(previewGeometry, blockMaterial2);

scene.add(previewBlock);


function animateOpacity() {
  const opacityValue = previewBlock.material.opacity;
showIndicationForWallsinOtherBlocks()
  
  const targetOpacity = opacityValue === 0.6 ? 0.2 : 0.6;

  
  const duration = 300; 
  const startTime = Date.now();

  function updateOpacity() {
    const currentTime = Date.now() - startTime;
    const progress = Math.min(currentTime / duration, 1);
    const newOpacity = opacityValue + (targetOpacity - opacityValue) * progress;

    previewBlock.material.opacity = newOpacity;

    if (progress < 1) {
      requestAnimationFrame(updateOpacity);

    }
  }

  updateOpacity();
}


setInterval(animateOpacity, 400);

let previewBlockAdded = false; 




function showIndicationForWallsinOtherBlocks(event) {
  updateInventory();
const playerChunkX = Math.floor(player.position.x / rdist);
const playerChunkZ = Math.floor(player.position.z / rdist);
  
  const mouse = new THREE.Vector2();
  mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
  mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

  
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(mouse, camera);

  
  const blocksInCurrentChunk = blocks.filter(block => {
    const blockChunkX = Math.floor(block.position.x / rdist);
    const blockChunkZ = Math.floor(block.position.z / rdist);
    return blockChunkX === playerChunkX && blockChunkZ === playerChunkZ;
  });

  const intersects = raycaster.intersectObjects(blocksInCurrentChunk);

  if (intersects.length > 0) {
    const clickedBlock = intersects[0].object;
    const blockPosition = new THREE.Vector3();
    clickedBlock.getWorldPosition(blockPosition);

    
    blockPosition.x = Math.floor(blockPosition.x);
    blockPosition.y = Math.floor(blockPosition.y);
    blockPosition.z = Math.floor(blockPosition.z);

    
    const intersectionPoint = intersects[0].point;
    const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

    let newPosition = blockPosition.clone();

    
    
    if (relativePosition.y > 0) {
      newPosition.y += 1;
    } else if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {
      
      newPosition.x += Math.sign(relativePosition.x);
    } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {
      
      newPosition.z += Math.sign(relativePosition.z);
    } else {
      
    }

    
    previewBlock.position.copy(newPosition);
    previewBlockAdded = true;

    
  } else {
    
    if (previewBlockAdded) {
      
      previewBlock.position.set(Infinity, Infinity, Infinity);
      previewBlockAdded = false;
      
    }
  }
}

function buildBlockOnClick(event) {
  updateInventory() 

    
    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth/2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight/2) / window.innerHeight) * 2 + 1;

    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    
    const intersects = raycaster.intersectObjects(blocks);

    if (intersects.length > 0) {
        
        const clickedBlock = intersects[0].object;
        const blockPosition = new THREE.Vector3();
        clickedBlock.getWorldPosition(blockPosition);

        
        blockPosition.x = Math.floor(blockPosition.x);
        blockPosition.y = Math.floor(blockPosition.y);
        blockPosition.z = Math.floor(blockPosition.z);

        
        const intersectionPoint = intersects[0].point;
        const relativePosition = new THREE.Vector3().copy(intersectionPoint).sub(blockPosition);

        

        if (currentblock == 'stone') {
          currentitemslot='stone';
          if(cantbuildthisblockGeometry==0){
          var newBlock = new THREE.Mesh(blockGeometry, wooden);
          newBlock.name="stone"
          var searchedItem = "stone";
          var index = -1; 

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key; 
              break; 
            }
          }
          useblock(index)
          }
        } else if (currentblock == 'wood'){
          currentitemslot='wood'

          if(cantbuildthisblockGeometry==0){
          var newBlock = new THREE.Mesh(blockGeometry, stonen);
          newBlock.name='wood'
          var searchedItem = "wood";
          var index = -1; 

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key; 
              break; 
            }
          }
          useblock(index)
          }
        }else if (currentblock == 'grass') {
          currentblock='grass'
          currentitemslot='grass'
          if(cantbuildthisblockGeometry==0){
          var newBlock = new THREE.Mesh(blockGeometry, materials );
          newBlock.name='grass'
          var searchedItem = "grass";
          var index = -1; 

          for (var key in items) {
            if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
              index = key; 
              break; 
            }
          }
          useblock(index)
          }
        }else{

currentitemslot = currentblock;

if (cantbuildthisblockGeometry === 0) {
  var newBlock = new THREE.Mesh(blockGeometry, materials);
  newBlock.name = currentitemslot;

  var searchedItem = currentitemslot;
  var index = -1; 

  for (var key in items) {
    if (items.hasOwnProperty(key) && items[key][0] === searchedItem) {
      index = key;
      break; 
    }
  }

  
  if (index !== -1) {
    if (items[index][3] && window.hasOwnProperty(items[index][3])) {
      
      var customMaterial = window[items[index][3]];
      newBlock.material = customMaterial;
    } else {
      
      var itemTexture = new THREE.TextureLoader().load(items[index][2]);
      itemTexture.magFilter = THREE.NearestFilter; 
      itemTexture.minFilter = THREE.NearestFilter; 
      var itemMaterial = new THREE.MeshBasicMaterial({ map: itemTexture });
      newBlock.material = itemMaterial;
    }
  }

  useblock(index);
}

        }

        let newPosition = blockPosition.clone();

        
                
        if (relativePosition.y > 0) {
          newPosition.y += 1;
        }
        else
        if (Math.abs(relativePosition.x) > Math.abs(relativePosition.z)) {
          
          newPosition.x += Math.sign(relativePosition.x);
        } else if (Math.abs(relativePosition.x) < Math.abs(relativePosition.z)) {
          
          newPosition.z += Math.sign(relativePosition.z);
        } else {
          
          newPosition.y += Math.sign(relativePosition.y);
        }

        var audio = new Audio('./stone4.ogg');

        
        audio.play();
        newBlock.position.copy(newPosition);

        scene.add(newBlock);
        blocks.push(newBlock);

    }
}
function deleteBlockOnClick(event) {
    const mouse = new THREE.Vector2();
    mouse.x = ((window.innerWidth / 2) / window.innerWidth) * 2 - 1;
    mouse.y = -((window.innerHeight / 2) / window.innerHeight) * 2 + 1;

    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    
    const intersects = raycaster.intersectObjects(blocks);

    if (intersects.length > 0) {
        
        const clickedBlock = intersects[0].object;

        
        if (clickedBlock.name === "stone") {
            addblock("stone");
        }else if (clickedBlock.name === "woodblock") {
          addblock("wood"); addblock("wood"); addblock("wood"); addblock("wood");
        } else if (clickedBlock.name === "grass") {
          addblock("grass");
        } else if (clickedBlock.name === "stone") {
          addblock("wood");
        }else {
addblock(clickedBlock.name)
        }
var audio = new Audio('./stone1.ogg');


audio.play();
        
        const index = blocks.indexOf(clickedBlock);
        if (index !== -1) {
            blocks.splice(index, 1);
            scene.remove(clickedBlock);
        }
    }
}


let elapsedTime = 0;










function changeBackgroundAndLight() {
  const duration = 15000; 
  const startTime = Date.now();
  const minLightIntensity = 0.02;

  const gameElement = document.getElementById('game');

  function update() {
    const currentTime = Date.now() - startTime;

    
    const progressLight = Math.min(currentTime / duration, 1);
    const newLightIntensity = Math.max(minLightIntensity, 0.3 - 0.2 * progressLight*2);
    light.intensity = newLightIntensity;

gameElement.classList.add('night')

    
    if (currentTime < duration) {
      requestAnimationFrame(update);

    }else{
      setTimeout(changeBackgroundAndLight2, 200000); 
    }
  }

  
  update();
}

setTimeout(changeBackgroundAndLight, 300000); 
function changeBackgroundAndLight2() {
  const duration = 35000; 
  const startTime = Date.now();
  const minLightIntensity = 0.02;

  const gameElement = document.getElementById('game');

  function update() {
    const currentTime = Date.now() - startTime;

    
    const progressLight = Math.min(currentTime / duration, 1);
    const newLightIntensity = Math.min(0.6, minLightIntensity + 0.2 * progressLight*2);
    light.intensity = newLightIntensity;

    gameElement.classList.add('day'); 

    
    if (currentTime < duration) {

      requestAnimationFrame(update);
      gameElement.classList.remove('night');
    }else{
      gameElement.classList.remove('day');
      setTimeout(changeBackgroundAndLight, 300000); 
    }
  }

  
  update();
}

currentblock='stone'
blockClickEnabled=false
function switchi(data) {
  if (data=="stone") {
    
    canv.removeEventListener('click', deleteBlockOnClick);
    canv.addEventListener('click', buildBlockOnClick);

currentblock='stone'
  }else if (data == "wood") {
    
    canv.removeEventListener('click', deleteBlockOnClick);
    canv.addEventListener('click', buildBlockOnClick);
    
    currentblock = 'wood'
  }else if (data == "grass") {
    
    canv.removeEventListener('click', deleteBlockOnClick);
    canv.addEventListener('click', buildBlockOnClick);
    
    currentblock = 'grass'
  }else if (data =="pickaxe"){
    
    canv.removeEventListener('click',buildBlockOnClick);
    canv.addEventListener('click', deleteBlockOnClick);

  }else{
    
    canv.removeEventListener('click', deleteBlockOnClick);
    canv.addEventListener('click', buildBlockOnClick);
    
    currentblock = data
  }
}

window.addEventListener('resize', function() {
  var newScreenWidth = window.innerWidth;
  var newScreenHeight = window.innerHeight;

  
  renderer.setSize(newScreenWidth, newScreenHeight);

  
  camera.aspect = newScreenWidth / newScreenHeight;
  camera.updateProjectionMatrix();
});

function fori(){
  camera.getWorldPosition(cameraPosition);
  camera.getWorldDirection(cameraDirection);

  
  var blockPosition = block.getWorldPosition(new THREE.Vector3());

  
  var directionToBlock = blockPosition.sub(cameraPosition).normalize();

  
  var dotProduct = cameraDirection.dot(directionToBlock);
  if (dotProduct > 0.99) { 
    
    block.material.color.set(0xffffff);
    block.material.emissive.set(0xffffff);
  } else {
    
    block.material.color.set(0x00ff00);
    block.material.emissive.set(0x000000);
  }
}


function test(){



}
window.setInterval(test,10000)

var hurtperseconds=0


let canHurt = true; 
let lastHurtTime = 0; 

function hurt() {
  jumpposition = player.position.y;
  const currentTime = Date.now();
  const timeSinceLastHurt = currentTime - lastHurtTime;
  document.getElementById('game').classList.add('dead');
  setTimeout(function() {
    document.getElementById('game').classList.remove('dead');
  }, 10000);

  
  var audio = new Audio('hurt.ogg');

  
  audio.play();

  
  if (timeSinceLastHurt >= 500) {
    

    const heartsContainer = document.getElementById("hearts");

    
    setTimeout(function() {
      if (heartsContainer.children.length > 0) {
        
        const lastHeart = heartsContainer.lastChild;
        heartsContainer.removeChild(lastHeart);

        
        if (heartsContainer.children.length === 0) {
          
          warn2("You died");

          
          for (var i = 0; i < 11; i++) {
            heartsContainer.innerHTML += '<div class="heart"></div>';
          }
          player.position.y = 15;
          player.position.x = 15;
          player.position.z = 15;
          playerVelocity.set(0, 0, 0);
       
        }
      }
    }, 1500);

    lastHurtTime = currentTime; 
  }
}



function test2(){
  
}



    </script>

<script>

 var audio2 = new Audio('./hal3.ogg');



 function playnaunce1(){
   let random =Math.floor(Math.random()*2) 

   if(audio2.paused){
     if (random == 0) {

       audio2.src = './hal3.ogg';
     } if(random == 1) {

       audio2.src = './nuance1.ogg';
       warn2(random)
     } if(random > 1 && random < 3){
       audio2.src='./calm3.ogg'
     }if (random > 2 && random < 4) {
       audio2.src = './calm2.ogg'
     }
     audio2.play();
   }

 }
 window.setInterval(playnaunce1,10000)
</script>

<script>

  
</script>

</div>
</html>
